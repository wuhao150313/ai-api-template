# Spring Boot API 项目从零搭建教程

基于 Spring Boot 3.5.5 的企业级 API 项目完整搭建教程，包含 JWT 认证、Redis 缓存、MyBatis-Plus、Docker 部署等完整功能。

## 目录

1. [使用 Maven 创建项目](#1-使用-maven-创建项目)
2. [创建目录和包结构](#2-创建目录和包结构)
3. [数据库设计](#3-数据库设计)
4. [配置文件](#4-配置文件)
5. [公共模块](#5-公共模块)
6. [配置类](#6-配置类)
7. [基础设施层](#7-基础设施层)
8. [认证模块](#8-认证模块)
9. [用户模块](#9-用户模块)
10. [启动类](#10-启动类)
11. [Docker 部署](#11-docker-部署)
12. [运行与测试](#12-运行与测试)

---

## 1. 使用 Maven 创建项目

### 1.1 使用 Maven 命令创建项目骨架

```bash
# 创建项目根目录
mkdir api-template
cd api-template

# 使用 Maven archetype 创建项目
mvn archetype:generate \
  -DgroupId=top.mqxu \
  -DartifactId=api-template \
  -Dversion=1.0.0 \
  -Dpackaging=jar \
  -DarchetypeGroupId=org.apache.maven.archetypes \
  -DarchetypeArtifactId=maven-archetype-quickstart \
  -DinteractiveMode=false

# 删除不需要的文件
rm -rf src/test/java/top/mqxu/api/AppTest.java
```

### 1.2 配置 pom.xml

将项目根目录下的 `pom.xml` 替换为以下内容：

```xml
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0
         http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>

    <parent>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-parent</artifactId>
        <version>3.5.5</version>
        <relativePath/>
    </parent>

    <groupId>top.mqxu</groupId>
    <artifactId>api-template</artifactId>
    <version>1.0.0</version>
    <name>api-template</name>
    <description>Spring Boot API 项目脚手架</description>

    <properties>
        <java.version>17</java.version>
        <maven.compiler.source>17</maven.compiler.source>
        <maven.compiler.target>17</maven.compiler.target>
        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
        <mybatis-plus.version>3.5.7</mybatis-plus.version>
        <hutool.version>5.8.40</hutool.version>
        <knife4j.version>4.5.0</knife4j.version>
        <springdoc.version>2.8.8</springdoc.version>
        <druid.version>1.2.25</druid.version>
        <mapstruct.version>1.5.5.Final</mapstruct.version>
        <jjwt.version>0.12.6</jjwt.version>
        <httpclient.version>4.5.14</httpclient.version>
        <cloopen.sms.version>1.0.4</cloopen.sms.version>
        <aliyun-oss.version>3.18.1</aliyun-oss.version>
    </properties>

    <dependencies>
        <!-- Spring Boot Starters -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-web</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-data-redis</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-validation</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-security</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-aop</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-actuator</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-configuration-processor</artifactId>
            <optional>true</optional>
        </dependency>

        <!-- Database -->
        <dependency>
            <groupId>com.mysql</groupId>
            <artifactId>mysql-connector-j</artifactId>
            <scope>runtime</scope>
        </dependency>
        <dependency>
            <groupId>com.baomidou</groupId>
            <artifactId>mybatis-plus-spring-boot3-starter</artifactId>
            <version>${mybatis-plus.version}</version>
        </dependency>
        <dependency>
            <groupId>com.alibaba</groupId>
            <artifactId>druid-spring-boot-3-starter</artifactId>
            <version>${druid.version}</version>
        </dependency>

        <!-- API Documentation -->
        <dependency>
            <groupId>com.github.xiaoymin</groupId>
            <artifactId>knife4j-openapi3-jakarta-spring-boot-starter</artifactId>
            <version>${knife4j.version}</version>
            <exclusions>
                <exclusion>
                    <groupId>org.springdoc</groupId>
                    <artifactId>springdoc-openapi-starter-webmvc-ui</artifactId>
                </exclusion>
            </exclusions>
        </dependency>
        <dependency>
            <groupId>org.springdoc</groupId>
            <artifactId>springdoc-openapi-starter-webmvc-ui</artifactId>
            <version>${springdoc.version}</version>
        </dependency>

        <!-- Utils -->
        <dependency>
            <groupId>org.projectlombok</groupId>
            <artifactId>lombok</artifactId>
            <optional>true</optional>
        </dependency>
        <dependency>
            <groupId>cn.hutool</groupId>
            <artifactId>hutool-all</artifactId>
            <version>${hutool.version}</version>
        </dependency>
        <dependency>
            <groupId>org.mapstruct</groupId>
            <artifactId>mapstruct</artifactId>
            <version>${mapstruct.version}</version>
        </dependency>
        <dependency>
            <groupId>org.mapstruct</groupId>
            <artifactId>mapstruct-processor</artifactId>
            <version>${mapstruct.version}</version>
            <scope>provided</scope>
        </dependency>
        <dependency>
            <groupId>org.apache.httpcomponents</groupId>
            <artifactId>httpclient</artifactId>
            <version>${httpclient.version}</version>
        </dependency>
        <dependency>
            <groupId>com.cloopen</groupId>
            <artifactId>java-sms-sdk</artifactId>
            <version>${cloopen.sms.version}</version>
        </dependency>
        <dependency>
            <groupId>com.aliyun.oss</groupId>
            <artifactId>aliyun-sdk-oss</artifactId>
            <version>${aliyun-oss.version}</version>
        </dependency>

        <!-- JWT -->
        <dependency>
            <groupId>io.jsonwebtoken</groupId>
            <artifactId>jjwt-api</artifactId>
            <version>${jjwt.version}</version>
        </dependency>
        <dependency>
            <groupId>io.jsonwebtoken</groupId>
            <artifactId>jjwt-impl</artifactId>
            <version>${jjwt.version}</version>
            <scope>runtime</scope>
        </dependency>
        <dependency>
            <groupId>io.jsonwebtoken</groupId>
            <artifactId>jjwt-jackson</artifactId>
            <version>${jjwt.version}</version>
            <scope>runtime</scope>
        </dependency>
    </dependencies>

    <build>
        <finalName>api-template</finalName>
        <plugins>
            <plugin>
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-maven-plugin</artifactId>
                <configuration>
                    <excludes>
                        <exclude>
                            <groupId>org.projectlombok</groupId>
                            <artifactId>lombok</artifactId>
                        </exclude>
                    </excludes>
                </configuration>
            </plugin>

            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-compiler-plugin</artifactId>
                <configuration>
                    <source>17</source>
                    <target>17</target>
                    <annotationProcessorPaths>
                        <path>
                            <groupId>org.projectlombok</groupId>
                            <artifactId>lombok</artifactId>
                            <version>${lombok.version}</version>
                        </path>
                        <path>
                            <groupId>org.mapstruct</groupId>
                            <artifactId>mapstruct-processor</artifactId>
                            <version>${mapstruct.version}</version>
                        </path>
                    </annotationProcessorPaths>
                </configuration>
            </plugin>
        </plugins>
    </build>

</project>
```

### 1.3 重新组织 Maven 目录结构

```bash
# 删除旧的 Maven 结构
rm -rf src/main/java/top/mqxu/api/App.java

# 创建标准的 Spring Boot 目录结构
mkdir -p src/main/java/top/mqxu/api
mkdir -p src/main/resources
mkdir -p src/test/java
```

---

## 2. 创建目录和包结构

### 2.1 使用脚本创建完整的目录结构

创建 `create-structure.sh` 脚本：

```bash
#!/bin/bash

# 创建主要目录
mkdir -p src/main/java/top/mqxu/api/{common,config,infrastructure,module}
mkdir -p src/main/resources/{mapper}
mkdir -p src/test/java

# 创建公共模块包结构
mkdir -p src/main/java/top/mqxu/api/common/{cache,entity,enums,exception,filter,handler,result,utils}

# 创建基础设施层包结构
mkdir -p src/main/java/top/mqxu/api/infrastructure/{oss,sms,wechat}

# 创建业务模块包结构
mkdir -p src/main/java/top/mqxu/api/module/{auth,user}
mkdir -p src/main/java/top/mqxu/api/module/auth/{model/{dto,vo},service/impl,controller}
mkdir -p src/main/java/top/mqxu/api/module/user/{model/{dto,vo,entity},mapper,service/impl,controller,convert}

# 创建 SQL 目录
mkdir -p sql

# 创建日志目录
mkdir -p logs

echo "项目目录结构创建完成！"
```

执行脚本：

```bash
chmod +x create-structure.sh
./create-structure.sh
rm create-structure.sh
```

### 2.2 最终目录结构

创建后的完整目录结构如下：

```
api-template/
├── src/
│   ├── main/
│   │   ├── java/top/mqxu/api/
│   │   │   ├── common/              # 公共模块
│   │   │   │   ├── cache/          # 缓存相关
│   │   │   │   ├── entity/         # 基础实体
│   │   │   │   ├── enums/          # 枚举类
│   │   │   │   ├── exception/      # 异常处理
│   │   │   │   ├── filter/         # 过滤器
│   │   │   │   ├── handler/        # 处理器
│   │   │   │   ├── result/         # 统一响应
│   │   │   │   └── utils/          # 工具类
│   │   │   ├── config/             # 配置类
│   │   │   ├── infrastructure/     # 基础设施层
│   │   │   │   ├── oss/            # 对象存储
│   │   │   │   ├── sms/            # 短信服务
│   │   │   │   └── wechat/         # 微信服务
│   │   │   ├── module/             # 业务模块
│   │   │   │   ├── auth/           # 认证模块
│   │   │   │   └── user/           # 用户模块
│   │   │   └── Application.java    # 启动类
│   │   └── resources/              # 资源文件
│   │       ├── mapper/             # MyBatis XML
│   │       └── *.yml              # 配置文件
│   └── test/                       # 测试代码
├── sql/                            # 数据库脚本
├── logs/                           # 日志目录
├── docs/                           # 文档
└── pom.xml                         # Maven 配置
```

---

## 3. 数据库设计

### 3.1 创建数据库脚本

在项目根目录创建 `sql` 目录，并在其中创建 `schema.sql` 文件：

```sql
-- 创建数据库
CREATE DATABASE IF NOT EXISTS api_template
DEFAULT CHARACTER SET utf8mb4
COLLATE utf8mb4_0900_ai_ci;

USE api_template;

-- 用户表
CREATE TABLE `sys_user`
(
    `id`          bigint      NOT NULL AUTO_INCREMENT COMMENT '主键',
    `username`    varchar(50) NOT NULL COMMENT '用户名',
    `password`    varchar(100) DEFAULT NULL COMMENT '密码',
    `real_name`   varchar(50)  DEFAULT NULL COMMENT '真实姓名',
    `email`       varchar(100) DEFAULT NULL COMMENT '邮箱',
    `mobile`      varchar(20)  DEFAULT NULL COMMENT '手机号',
    `avatar`      varchar(200) DEFAULT NULL COMMENT '头像',
    `nickname`    varchar(50)  DEFAULT NULL COMMENT '昵称',
    `gender`      tinyint      DEFAULT '0' COMMENT '性别 0:未知 1:男 2:女',
    `wx_openid`   varchar(100) DEFAULT NULL COMMENT '微信openid',
    `status`      tinyint      DEFAULT '1' COMMENT '状态 0:禁用 1:正常',
    `create_time` datetime     DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',
    `update_time` datetime     DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT '更新时间',
    `deleted`     tinyint      DEFAULT '0' COMMENT '删除标记 0:未删除 1:已删除',
    PRIMARY KEY (`id`),
    UNIQUE KEY `uk_username` (`username`) USING BTREE,
    KEY           `idx_mobile` (`mobile`),
    KEY           `idx_wx_openid` (`wx_openid`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci COMMENT='用户表';

-- 默认密码: 123456
INSERT INTO `sys_user` (`username`,
                        `password`,
                        `nickname`,
                        `mobile`,
                        `status`)
VALUES ('admin',
        '$2a$10$/ymWYgifpcgV.bRZYySYveiG0E7Q9h4A8bTpxm/9cEJd1aUZwIh26',
        '管理员',
        '13800138000',
        1);
```

### 3.2 创建数据库

```bash
# 使用 MySQL 客户端创建数据库
mysql -u root -p < sql/schema.sql
```

---

## 4. 配置文件

### 4.1 主配置文件 application.yml

在 `src/main/resources/` 目录下创建 `application.yml`：

```yaml
# Tomcat
server:
  tomcat:
    uri-encoding: UTF-8
    threads:
      max: 1000
      min-spare: 30
  port: 8083
  servlet:
    context-path: /
    session:
      cookie:
        http-only: true

# Knife4j 配置
knife4j:
  enable: false
  setting:
    custom-code: 500
    enable-footer-custom: false

spring:
  config:
    import:
      - optional:classpath:application-secret.properties
  profiles:
    active: dev
  application:
    name: api-template
  jackson:
    time-zone: GMT+8
  servlet:
    multipart:
      max-file-size: 1024MB
      max-request-size: 1024MB

mybatis-plus:
  mapper-locations: classpath:mapper/*.xml
  typeAliasesPackage: top.mqxu.api.module.*.entity
  global-config:
    db-config:
      id-type: AUTO
      logic-delete-field: deleted
      logic-delete-value: 1
      logic-not-delete-value: 0
  # 原生配置
  configuration:
    map-underscore-to-camel-case: true
    cache-enabled: false
    call-setters-on-nulls: true
    jdbc-type-for-null: 'null'
    log-impl: org.apache.ibatis.logging.stdout.StdOutImpl
  configuration-properties:
    prefix:
    blobType: BLOB
    boolValue: TRUE

# JWT 配置（从 application-secret.properties 读取）
jwt:
  secret: ${jwt.secret}
  expiration: ${jwt.expiration}

# 容联云短信配置（从 application-secret.properties 读取）
ronglian:
  server: ${ronglian.server}
  port: ${ronglian.port}
  account-sid: ${ronglian.account-sid}
  auth-token: ${ronglian.auth-token}
  app-id: ${ronglian.app-id}
  rest-url: https://${ronglian.server}:${ronglian.port}
  template-id: ${ronglian.template-id}

# 阿里云 OSS 配置（从 application-secret.properties 读取）
aliyun:
  oss:
    endpoint: ${aliyun.oss.endpoint}
    access-key: ${aliyun.oss.access-key}
    access-secret: ${aliyun.oss.access-secret}
    bucket: ${aliyun.oss.bucket}
    host: ${aliyun.oss.bucket}.${aliyun.oss.endpoint}

# 微信 API 配置（从 application-secret.properties 读取）
wechat:
  url: https://api.weixin.qq.com/sns/jscode2session
  app-id: ${wechat.app-id}
  app-secret: ${wechat.app-secret}
```

### 4.2 开发环境配置 application-dev.yml

在 `src/main/resources/` 目录下创建 `application-dev.yml`：

```yaml
# 开发环境配置
spring:
  data:
    redis:
      host: localhost
      port: 6379
      password:
      database: 0
  datasource:
    driver-class-name: com.mysql.cj.jdbc.Driver
    url: jdbc:mysql://localhost:3306/api_template?useSSL=false&serverTimezone=Asia/Shanghai&characterEncoding=utf8&useUnicode=true&allowPublicKeyRetrieval=true
    username: root
    password: 123456
    hikari:
      # 连接池配置
      maximum-pool-size: 50
      minimum-idle: 10
      connection-timeout: 30000
      idle-timeout: 600000
      max-lifetime: 1800000
      # 连接测试配置
      connection-test-query: SELECT 1
      validation-timeout: 5000
      # 连接命名（便于调试）
      pool-name: HikariCP-Production

# 开发环境日志配置（在 logback-spring.xml 中管理）
```

### 4.3 生产环境配置 application-prod.yml

在 `src/main/resources/` 目录下创建 `application-prod.yml`：

```yaml
# 生产环境配置
spring:
  data:
    redis:
      host: ${REDIS_HOST:redis}
      port: ${REDIS_PORT:6379}
      password: ${REDIS_PASSWORD:}
      database: 0
  datasource:
    driver-class-name: com.mysql.cj.jdbc.Driver
    url: jdbc:mysql://${MYSQL_HOST:mysql}:${MYSQL_PORT:3306}/${MYSQL_DATABASE:api_template}?useSSL=true&serverTimezone=Asia/Shanghai&characterEncoding=utf8&useUnicode=true&allowPublicKeyRetrieval=true
    username: ${MYSQL_USERNAME:root}
    password: ${MYSQL_PASSWORD:123456}
    hikari:
      # 连接池配置
      maximum-pool-size: 50
      minimum-idle: 10
      connection-timeout: 30000
      idle-timeout: 600000
      max-lifetime: 1800000
      # 连接测试配置
      connection-test-query: SELECT 1
      validation-timeout: 5000
      # 连接命名（便于调试）
      pool-name: HikariCP-Production
```

### 4.4 敏感配置文件 application-secret.properties.example

在 `src/main/resources/` 目录下创建 `application-secret.properties.example`：

```properties
# 应用敏感配置示例
# 复制此文件为 application-secret.properties 并填入实际值
# 此文件包含敏感信息，请不要提交到代码仓库

# ========================================
# JWT 配置
# ========================================
jwt.secret=your-256-bit-secret-key-for-jwt-token-generation-min-32-chars
jwt.expiration=86400000

# ========================================
# 短信服务配置
# ========================================
ronglian.server=app.cloopen.com
ronglian.port=8883
ronglian.account-sid=your_account_sid
ronglian.auth-token=your_auth_token
ronglian.app-id=your_app_id
ronglian.template-id=1

# ========================================
# 微信配置
# ========================================
wechat.app-id=your_wechat_app_id
wechat.app-secret=your_wechat_app_secret

# ========================================
# 阿里云 OSS 配置
# ========================================
aliyun.oss.endpoint=oss-cn-hangzhou.aliyuncs.com
aliyun.oss.access-key=your_access_key
aliyun.oss.access-secret=your_access_secret
aliyun.oss.bucket=your_bucket_name
```

### 4.5 日志配置 logback-spring.xml

在 `src/main/resources/` 目录下创建 `logback-spring.xml`：

```xml
<?xml version="1.0" encoding="UTF-8"?>
<configuration>
    <!-- 日志存放路径 -->
    <property name="log.path" value="logs"/>
    <!-- 日志输出格式 -->
    <property name="log.pattern" value="%d{yyyy-MM-dd HH:mm:ss.SSS} [%thread] %-5level %logger{20} - [%method,%line] - %msg%n"/>

    <!-- 控制台输出 -->
    <appender name="console" class="ch.qos.logback.core.ConsoleAppender">
        <encoder>
            <pattern>${log.pattern}</pattern>
        </encoder>
    </appender>

    <!-- 系统日志输出 -->
    <appender name="file_info" class="ch.qos.logback.core.rolling.RollingFileAppender">
        <file>${log.path}/sys-info.log</file>
        <!-- 循环政策：基于时间创建日志文件 -->
        <rollingPolicy class="ch.qos.logback.core.rolling.TimeBasedRollingPolicy">
            <!-- 日志文件名格式 -->
            <fileNamePattern>${log.path}/sys-info.%d{yyyy-MM-dd}.log</fileNamePattern>
            <!-- 日志最大的历史 30 天 -->
            <maxHistory>30</maxHistory>
        </rollingPolicy>
        <encoder>
            <pattern>${log.pattern}</pattern>
        </encoder>
        <filter class="ch.qos.logback.classic.filter.LevelFilter">
            <!-- 过滤的级别 -->
            <level>INFO</level>
            <!-- 匹配时的操作：接收（记录） -->
            <onMatch>ACCEPT</onMatch>
            <!-- 不匹配时的操作：拒绝（不记录） -->
            <onMismatch>DENY</onMismatch>
        </filter>
    </appender>

    <appender name="file_error" class="ch.qos.logback.core.rolling.RollingFileAppender">
        <file>${log.path}/sys-error.log</file>
        <!-- 循环政策：基于时间创建日志文件 -->
        <rollingPolicy class="ch.qos.logback.core.rolling.TimeBasedRollingPolicy">
            <!-- 日志文件名格式 -->
            <fileNamePattern>${log.path}/sys-error.%d{yyyy-MM-dd}.log</fileNamePattern>
            <!-- 日志最大的历史 30 天 -->
            <maxHistory>30</maxHistory>
        </rollingPolicy>
        <encoder>
            <pattern>${log.pattern}</pattern>
        </encoder>
        <filter class="ch.qos.logback.classic.filter.LevelFilter">
            <!-- 过滤的级别 -->
            <level>ERROR</level>
            <!-- 匹配时的操作：接收（记录） -->
            <onMatch>ACCEPT</onMatch>
            <!-- 不匹配时的操作：拒绝（不记录） -->
            <onMismatch>DENY</onMismatch>
        </filter>
    </appender>

    <!-- Spring日志级别控制 -->
    <logger name="org.springframework" level="warn"/>

    <!-- 系统模块日志级别控制 -->
    <logger name="top.mqxu" level="debug"/>

    <!-- 系统用户操作日志 -->
    <logger name="sys-user" level="debug"/>

    <!-- 系统日志输出级别 -->
    <root level="info">
        <appender-ref ref="console"/>
        <appender-ref ref="file_info"/>
        <appender-ref ref="file_error"/>
    </root>

    <!--开发环境:打印控制台日志-->
    <springProfile name="dev">
        <logger name="top.mqxu" level="debug"/>
    </springProfile>

    <!--生产环境:输出到文件-->
    <springProfile name="prod">
        <root level="info">
            <appender-ref ref="file_info"/>
            <appender-ref ref="file_error"/>
        </root>
    </springProfile>
</configuration>
```

---

## 5. 公共模块

公共模块包含项目中的通用类，如基础实体、枚举、工具类等。

### 5.1 基础实体类

创建 `src/main/java/top/mqxu/api/common/entity/BaseEntity.java`：

```java
package top.mqxu.api.common.entity;

import com.baomidou.mybatisplus.annotation.*;
import lombok.Data;
import lombok.experimental.Accessors;

import java.io.Serial;
import java.time.LocalDateTime;

/**
 * 基础实体类
 *
 * @author mqxu
 */
@Data
@Accessors(chain = true)
public class BaseEntity {

    @Serial
    private static final long serialVersionUID = 1L;

    /**
     * 主键ID
     */
    @TableId(value = "id", type = IdType.AUTO)
    private Long id;

    /**
     * 创建时间
     */
    @TableField(value = "create_time", fill = FieldFill.INSERT)
    private LocalDateTime createTime;

    /**
     * 更新时间
     */
    @TableField(value = "update_time", fill = FieldFill.INSERT_UPDATE)
    private LocalDateTime updateTime;

    /**
     * 删除标记 0:未删除 1:已删除
     */
    @TableLogic
    @TableField("deleted")
    private Integer deleted;
}
```

### 5.2 枚举类

#### 5.2.1 删除标记枚举

创建 `src/main/java/top/mqxu/api/common/enums/DeletedEnum.java`：

```java
package top.mqxu.api.common.enums;

/**
 * 删除标记枚举
 *
 * @author mqxu
 */
public enum DeletedEnum {
    /**
     * 未删除
     */
    NOT_DELETED(0),

    /**
     * 已删除
     */
    DELETED(1);

    private final Integer code;

    DeletedEnum(Integer code) {
        this.code = code;
    }

    public Integer getCode() {
        return code;
    }
}
```

#### 5.2.2 性别枚举

创建 `src/main/java/top/mqxu/api/common/enums/GenderEnum.java`：

```java
package top.mqxu.api.common.enums;

/**
 * 性别枚举
 *
 * @author mqxu
 */
public enum GenderEnum {
    /**
     * 未知
     */
    UNKNOWN(0, "未知"),

    /**
     * 男
     */
    MALE(1, "男"),

    /**
     * 女
     */
    FEMALE(2, "女");

    private final Integer code;
    private final String desc;

    GenderEnum(Integer code, String desc) {
        this.code = code;
        this.desc = desc;
    }

    public Integer getCode() {
        return code;
    }

    public String getDesc() {
        return desc;
    }
}
```

#### 5.2.3 状态枚举

创建 `src/main/java/top/mqxu/api/common/enums/StatusEnum.java`：

```java
package top.mqxu.api.common.enums;

/**
 * 状态枚举
 *
 * @author mqxu
 */
public enum StatusEnum {
    /**
     * 禁用
     */
    DISABLED(0, "禁用"),

    /**
     * 正常
     */
    NORMAL(1, "正常");

    private final Integer code;
    private final String desc;

    StatusEnum(Integer code, String desc) {
        this.code = code;
        this.desc = desc;
    }

    public Integer getCode() {
        return code;
    }

    public String getDesc() {
        return desc;
    }
}
```

### 5.3 统一响应格式

#### 5.3.1 响应状态码

创建 `src/main/java/top/mqxu/api/common/result/ResultCode.java`：

```java
package top.mqxu.api.common.result;

/**
 * 响应状态码
 *
 * @author mqxu
 */
public enum ResultCode {
    /**
     * 操作成功
     */
    SUCCESS(200, "操作成功"),

    /**
     * 操作失败
     */
    FAIL(500, "操作失败"),

    /**
     * 参数错误
     */
    PARAM_ERROR(400, "参数错误"),

    /**
     * 未登录
     */
    UNAUTHORIZED(401, "未登录"),

    /**
     * 没有权限
     */
    FORBIDDEN(403, "没有权限"),

    /**
     * 资源不存在
     */
    NOT_FOUND(404, "资源不存在"),

    /**
     * 系统异常
     */
    SYSTEM_ERROR(500, "系统异常");

    private final Integer code;
    private final String message;

    ResultCode(Integer code, String message) {
        this.code = code;
        this.message = message;
    }

    public Integer getCode() {
        return code;
    }

    public String getMessage() {
        return message;
    }
}
```

#### 5.3.2 统一响应结果

创建 `src/main/java/top/mqxu/api/common/result/Result.java`：

```java
package top.mqxu.api.common.result;

import lombok.Data;
import lombok.experimental.Accessors;

/**
 * 统一响应结果
 *
 * @author mqxu
 */
@Data
@Accessors(chain = true)
public class Result<T> {
    /**
     * 响应码
     */
    private Integer code;

    /**
     * 响应消息
     */
    private String message;

    /**
     * 响应数据
     */
    private T data;

    /**
     * 构造方法
     */
    private Result() {
    }

    /**
     * 成功
     */
    public static <T> Result<T> ok() {
        return ok(null);
    }

    /**
     * 成功
     */
    public static <T> Result<T> ok(T data) {
        Result<T> result = new Result<>();
        result.setCode(ResultCode.SUCCESS.getCode());
        result.setMessage(ResultCode.SUCCESS.getMessage());
        result.setData(data);
        return result;
    }

    /**
     * 失败
     */
    public static <T> Result<T> fail() {
        return fail(ResultCode.FAIL.getMessage());
    }

    /**
     * 失败
     */
    public static <T> Result<T> fail(String message) {
        return fail(ResultCode.FAIL.getCode(), message);
    }

    /**
     * 失败
     */
    public static <T> Result<T> fail(Integer code, String message) {
        Result<T> result = new Result<>();
        result.setCode(code);
        result.setMessage(message);
        return result;
    }
}
```

#### 5.3.3 分页响应结果

创建 `src/main/java/top/mqxu/api/common/result/PageResult.java`：

```java
package top.mqxu.api.common.result;

import lombok.Data;
import lombok.experimental.Accessors;

import java.util.List;

/**
 * 分页响应结果
 *
 * @author mqxu
 */
@Data
@Accessors(chain = true)
public class PageResult<T> {
    /**
     * 数据列表
     */
    private List<T> records;

    /**
     * 总记录数
     */
    private Long total;

    /**
     * 构造方法
     */
    public PageResult() {
    }

    /**
     * 构造方法
     */
    public PageResult(List<T> records, Long total) {
        this.records = records;
        this.total = total;
    }
}
```

### 5.4 异常处理

#### 5.4.1 业务异常

创建 `src/main/java/top/mqxu/api/common/exception/ServerException.java`：

```java
package top.mqxu.api.common.exception;

import lombok.Getter;
import top.mqxu.api.common.result.ResultCode;

import java.io.Serial;

/**
 * 自定义业务异常
 *
 * @author mqxu
 */
@Getter
public class ServerException extends RuntimeException {

    @Serial
    private static final long serialVersionUID = 1L;

    private final int code;

    public ServerException(String message) {
        super(message);
        this.code = ResultCode.FAIL.getCode();
    }

    public ServerException(int code, String message) {
        super(message);
        this.code = code;
    }

    public ServerException(ResultCode resultCode) {
        super(resultCode.getMessage());
        this.code = resultCode.getCode();
    }
}
```

#### 5.4.2 全局异常处理器

创建 `src/main/java/top/mqxu/api/common/exception/GlobalExceptionHandler.java`：

```java
package top.mqxu.api.common.exception;

import lombok.extern.slf4j.Slf4j;
import org.springframework.http.HttpStatus;
import org.springframework.security.access.AccessDeniedException;
import org.springframework.security.authentication.BadCredentialsException;
import org.springframework.security.core.AuthenticationException;
import org.springframework.validation.BindException;
import org.springframework.validation.FieldError;
import org.springframework.web.bind.MethodArgumentNotValidException;
import org.springframework.web.bind.annotation.ExceptionHandler;
import org.springframework.web.bind.annotation.ResponseStatus;
import org.springframework.web.bind.annotation.RestControllerAdvice;
import top.mqxu.api.common.result.Result;

import java.util.List;

/**
 * 全局异常处理器
 *
 * @author mqxu
 */
@Slf4j
@RestControllerAdvice
public class GlobalExceptionHandler {

    /**
     * 处理业务异常
     */
    @ExceptionHandler(ServerException.class)
    @ResponseStatus(HttpStatus.OK)
    public Result<Object> handleServerException(ServerException e) {
        log.error("业务异常: {}", e.getMessage());
        return Result.fail(e.getCode(), e.getMessage());
    }

    /**
     * 处理参数校验异常
     */
    @ExceptionHandler(MethodArgumentNotValidException.class)
    @ResponseStatus(HttpStatus.BAD_REQUEST)
    public Result<Object> handleMethodArgumentNotValidException(MethodArgumentNotValidException e) {
        List<FieldError> fieldErrors = e.getBindingResult().getFieldErrors();
        String message = fieldErrors.isEmpty() ? "参数校验失败" : fieldErrors.get(0).getDefaultMessage();
        log.error("参数校验异常: {}", message);
        return Result.fail(ResultCode.PARAM_ERROR.getCode(), message);
    }

    /**
     * 处理参数绑定异常
     */
    @ExceptionHandler(BindException.class)
    @ResponseStatus(HttpStatus.BAD_REQUEST)
    public Result<Object> handleBindException(BindException e) {
        List<FieldError> fieldErrors = e.getBindingResult().getFieldErrors();
        String message = fieldErrors.isEmpty() ? "参数绑定失败" : fieldErrors.get(0).getDefaultMessage();
        log.error("参数绑定异常: {}", message);
        return Result.fail(ResultCode.PARAM_ERROR.getCode(), message);
    }

    /**
     * 处理认证异常
     */
    @ExceptionHandler(AuthenticationException.class)
    @ResponseStatus(HttpStatus.UNAUTHORIZED)
    public Result<Object> handleAuthenticationException(AuthenticationException e) {
        log.error("认证异常: {}", e.getMessage());
        return Result.fail(ResultCode.UNAUTHORIZED.getCode(), e.getMessage());
    }

    /**
     * 处理权限不足异常
     */
    @ExceptionHandler(AccessDeniedException.class)
    @ResponseStatus(HttpStatus.FORBIDDEN)
    public Result<Object> handleAccessDeniedException(AccessDeniedException e) {
        log.error("权限不足异常: {}", e.getMessage());
        return Result.fail(ResultCode.FORBIDDEN.getCode(), "没有权限访问该资源");
    }

    /**
     * 处理其他异常
     */
    @ExceptionHandler(Exception.class)
    @ResponseStatus(HttpStatus.INTERNAL_SERVER_ERROR)
    public Result<Object> handleException(Exception e) {
        log.error("系统异常: ", e);
        return Result.fail(ResultCode.SYSTEM_ERROR.getCode(), "系统异常，请稍后重试");
    }
}
```

### 5.5 缓存封装

#### 5.5.1 Redis 键常量

创建 `src/main/java/top/mqxu/api/common/cache/RedisKeys.java`：

```java
package top.mqxu.api.common.cache;

import lombok.experimental.UtilityClass;

/**
 * Redis 键常量
 *
 * @author mqxu
 */
@UtilityClass
public class RedisKeys {
    /**
     * 用户信息缓存
     */
    public static final String USER_INFO = "user:info:";

    /**
     * 用户权限缓存
     */
    public static final String USER_PERMISSIONS = "user:permissions:";

    /**
     * 短信验证码
     */
    public static final String SMS_CODE = "sms:code:";

    /**
     * JWT 黑名单
     */
    public static final String JWT_BLACKLIST = "jwt:blacklist:";

    /**
     * 微信用户信息缓存
     */
    public static final String WECHAT_USER = "wechat:user:";
}
```

#### 5.5.2 Redis 缓存工具类

创建 `src/main/java/top/mqxu/api/common/cache/RedisCache.java`：

```java
package top.mqxu.api.common.cache;

import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.data.redis.core.RedisTemplate;
import org.springframework.stereotype.Component;

import java.util.Collection;
import java.util.concurrent.TimeUnit;

/**
 * Redis 缓存工具类
 *
 * @author mqxu
 */
@Slf4j
@Component
@RequiredArgsConstructor
public class RedisCache {

    private final RedisTemplate<String, Object> redisTemplate;

    /**
     * 设置缓存
     *
     * @param key   键
     * @param value 值
     */
    public void set(String key, Object value) {
        redisTemplate.opsForValue().set(key, value);
    }

    /**
     * 设置缓存并指定过期时间
     *
     * @param key      键
     * @param value    值
     * @param timeout  过期时间
     * @param timeUnit 时间单位
     */
    public void set(String key, Object value, long timeout, TimeUnit timeUnit) {
        redisTemplate.opsForValue().set(key, value, timeout, timeUnit);
    }

    /**
     * 获取缓存
     *
     * @param key 键
     * @return 值
     */
    public Object get(String key) {
        return redisTemplate.opsForValue().get(key);
    }

    /**
     * 删除缓存
     *
     * @param key 键
     */
    public void delete(String key) {
        redisTemplate.delete(key);
    }

    /**
     * 批量删除缓存
     *
     * @param keys 键集合
     */
    public void delete(Collection<String> keys) {
        redisTemplate.delete(keys);
    }

    /**
     * 判断缓存是否存在
     *
     * @param key 键
     * @return 是否存在
     */
    public boolean hasKey(String key) {
        return Boolean.TRUE.equals(redisTemplate.hasKey(key));
    }

    /**
     * 设置过期时间
     *
     * @param key      键
     * @param timeout  过期时间
     * @param timeUnit 时间单位
     */
    public void expire(String key, long timeout, TimeUnit timeUnit) {
        redisTemplate.expire(key, timeout, timeUnit);
    }

    /**
     * 获取过期时间
     *
     * @param key 键
     * @return 过期时间（秒）
     */
    public long getExpire(String key) {
        return redisTemplate.getExpire(key, TimeUnit.SECONDS);
    }
}
```

### 5.6 工具类

#### 5.6.1 JWT 工具类

创建 `src/main/java/top/mqxu/api/common/utils/JwtUtils.java`：

```java
package top.mqxu.api.common.utils;

import io.jsonwebtoken.*;
import io.jsonwebtoken.security.Keys;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Component;

import javax.crypto.SecretKey;
import java.nio.charset.StandardCharsets;
import java.util.Date;

/**
 * JWT 工具类
 *
 * @author mqxu
 */
@Slf4j
@Component
@RequiredArgsConstructor
public class JwtUtils {

    @Value("${jwt.secret}")
    private String secret;

    @Value("${jwt.expiration}")
    private Long expiration;

    /**
     * 生成 Token
     *
     * @param userId 用户ID
     * @return Token
     */
    public String generateToken(Long userId) {
        Date now = new Date();
        Date expireTime = new Date(now.getTime() + expiration);

        SecretKey key = Keys.hmacShaKeyFor(secret.getBytes(StandardCharsets.UTF_8));

        return Jwts.builder()
                .setSubject(userId.toString())
                .setIssuedAt(now)
                .setExpiration(expireTime)
                .signWith(key, SignatureAlgorithm.HS256)
                .compact();
    }

    /**
     * 解析 Token 获取用户ID
     *
     * @param token Token
     * @return 用户ID
     */
    public Long parseToken(String token) {
        SecretKey key = Keys.hmacShaKeyFor(secret.getBytes(StandardCharsets.UTF_8));

        Claims claims = Jwts.parserBuilder()
                .setSigningKey(key)
                .build()
                .parseClaimsJws(token)
                .getBody();

        return Long.parseLong(claims.getSubject());
    }

    /**
     * 验证 Token 是否有效
     *
     * @param token Token
     * @return 是否有效
     */
    public boolean validateToken(String token) {
        try {
            SecretKey key = Keys.hmacShaKeyFor(secret.getBytes(StandardCharsets.UTF_8));

            Jwts.parserBuilder()
                    .setSigningKey(key)
                    .build()
                    .parseClaimsJws(token);

            return true;
        } catch (JwtException | IllegalArgumentException e) {
            log.error("Token 验证失败: {}", e.getMessage());
            return false;
        }
    }

    /**
     * 获取 Token 过期时间
     *
     * @param token Token
     * @return 过期时间
     */
    public Date getExpirationDateFromToken(String token) {
        SecretKey key = Keys.hmacShaKeyFor(secret.getBytes(StandardCharsets.UTF_8));

        Claims claims = Jwts.parserBuilder()
                .setSigningKey(key)
                .build()
                .parseClaimsJws(token)
                .getBody();

        return claims.getExpiration();
    }

    /**
     * 判断 Token 是否即将过期（剩余时间小于 30 分钟）
     *
     * @param token Token
     * @return 是否即将过期
     */
    public boolean isTokenExpiringSoon(String token) {
        Date expiration = getExpirationDateFromToken(token);
        long diff = expiration.getTime() - System.currentTimeMillis();
        return diff < 30 * 60 * 1000; // 30 分钟
    }
}
```

#### 5.6.2 安全工具类

创建 `src/main/java/top/mqxu/api/common/utils/SecurityUtils.java`：

```java
package top.mqxu.api.common.utils;

import lombok.RequiredArgsConstructor;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.stereotype.Component;

/**
 * 安全工具类
 *
 * @author mqxu
 */
@Component
@RequiredArgsConstructor
public class SecurityUtils {

    /**
     * 获取当前登录用户ID
     *
     * @return 用户ID
     */
    public static Long getCurrentUserId() {
        Authentication authentication = SecurityContextHolder.getContext().getAuthentication();
        if (authentication != null && authentication.getPrincipal() instanceof UserDetails) {
            CustomUserDetails userDetails = (CustomUserDetails) authentication.getPrincipal();
            return userDetails.getUserId();
        }
        return null;
    }

    /**
     * 获取当前登录用户名
     *
     * @return 用户名
     */
    public static String getCurrentUsername() {
        Authentication authentication = SecurityContextHolder.getContext().getAuthentication();
        if (authentication != null) {
            return authentication.getName();
        }
        return null;
    }

    /**
     * 获取当前认证信息
     *
     * @return 认证信息
     */
    public static Authentication getCurrentAuthentication() {
        return SecurityContextHolder.getContext().getAuthentication();
    }

    /**
     * 判断是否已认证
     *
     * @return 是否已认证
     */
    public static boolean isAuthenticated() {
        Authentication authentication = getCurrentAuthentication();
        return authentication != null && authentication.isAuthenticated();
    }
}
```

### 5.7 过滤器

#### 5.7.1 请求日志过滤器

创建 `src/main/java/top/mqxu/api/common/filter/LogFilter.java`：

```java
package top.mqxu.api.common.filter;

import jakarta.servlet.*;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Component;

import java.io.IOException;

/**
 * 请求日志过滤器
 *
 * @author mqxu
 */
@Slf4j
@Component
public class LogFilter implements Filter {

    @Override
    public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException {
        HttpServletRequest request = (HttpServletRequest) servletRequest;
        HttpServletResponse response = (HttpServletResponse) servletResponse;

        long startTime = System.currentTimeMillis();

        String method = request.getMethod();
        String uri = request.getRequestURI();
        String queryString = request.getQueryString();
        String ip = getIpAddr(request);

        log.info("========================================");
        log.info("请求开始 >>> {} {}", method, uri + (queryString != null ? "?" + queryString : ""));
        log.info("客户端IP: {}", ip);

        try {
            filterChain.doFilter(request, response);
        } finally {
            long endTime = System.currentTimeMillis();
            long executeTime = endTime - startTime;
            int status = response.getStatus();

            log.info("请求结束 <<< {} {} [状态码: {}] [耗时: {}ms]", method, uri, status, executeTime);
            log.info("========================================");
        }
    }

    /**
     * 获取客户端IP地址
     */
    private String getIpAddr(HttpServletRequest request) {
        String ip = request.getHeader("X-Forwarded-For");
        if (ip == null || ip.isEmpty() || "unknown".equalsIgnoreCase(ip)) {
            ip = request.getHeader("Proxy-Client-IP");
        }
        if (ip == null || ip.isEmpty() || "unknown".equalsIgnoreCase(ip)) {
            ip = request.getHeader("WL-Proxy-Client-IP");
        }
        if (ip == null || ip.isEmpty() || "unknown".equalsIgnoreCase(ip)) {
            ip = request.getHeader("HTTP_CLIENT_IP");
        }
        if (ip == null || ip.isEmpty() || "unknown".equalsIgnoreCase(ip)) {
            ip = request.getHeader("HTTP_X_FORWARDED_FOR");
        }
        if (ip == null || ip.isEmpty() || "unknown".equalsIgnoreCase(ip)) {
            ip = request.getRemoteAddr();
        }
        return ip;
    }
}
```

#### 5.7.2 JWT 认证过滤器

创建 `src/main/java/top/mqxu/api/common/filter/JwtAuthenticationFilter.java`：

```java
package top.mqxu.api.common.filter;

import com.fasterxml.jackson.databind.ObjectMapper;
import jakarta.servlet.FilterChain;
import jakarta.servlet.ServletException;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.http.MediaType;
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.security.core.userdetails.UserDetailsService;
import org.springframework.security.web.authentication.WebAuthenticationDetailsSource;
import org.springframework.stereotype.Component;
import org.springframework.util.StringUtils;
import org.springframework.web.filter.OncePerRequestFilter;
import top.mqxu.api.common.cache.RedisCache;
import top.mqxu.api.common.result.Result;
import top.mqxu.api.common.utils.JwtUtils;

import java.io.IOException;

/**
 * JWT 认证过滤器
 *
 * @author mqxu
 */
@Slf4j
@Component
@RequiredArgsConstructor
public class JwtAuthenticationFilter extends OncePerRequestFilter {

    private final JwtUtils jwtUtils;
    private final UserDetailsService userDetailsService;
    private final RedisCache redisCache;
    private final ObjectMapper objectMapper;

    @Override
    protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain) throws ServletException, IOException {
        String token = getTokenFromRequest(request);

        if (StringUtils.hasText(token)) {
            // 检查 Token 是否在黑名单中
            if (redisCache.hasKey(RedisKeys.JWT_BLACKLIST + token)) {
                sendErrorResponse(response, "Token 已失效，请重新登录");
                return;
            }

            try {
                Long userId = jwtUtils.parseToken(token);
                UserDetails userDetails = userDetailsService.loadUserByUsername(userId.toString());

                UsernamePasswordAuthenticationToken authentication = new UsernamePasswordAuthenticationToken(
                        userDetails, null, userDetails.getAuthorities());
                authentication.setDetails(new WebAuthenticationDetailsSource().buildDetails(request));

                SecurityContextHolder.getContext().setAuthentication(authentication);
            } catch (Exception e) {
                log.error("Token 解析失败: {}", e.getMessage());
                sendErrorResponse(response, "Token 无效");
                return;
            }
        }

        filterChain.doFilter(request, response);
    }

    /**
     * 从请求中获取 Token
     */
    private String getTokenFromRequest(HttpServletRequest request) {
        String bearerToken = request.getHeader("Authorization");
        if (StringUtils.hasText(bearerToken) && bearerToken.startsWith("Bearer ")) {
            return bearerToken.substring(7);
        }
        return null;
    }

    /**
     * 发送错误响应
     */
    private void sendErrorResponse(HttpServletResponse response, String message) throws IOException {
        response.setContentType(MediaType.APPLICATION_JSON_VALUE);
        response.setCharacterEncoding("UTF-8");

        Result<Object> result = Result.fail(401, message);
        response.getWriter().write(objectMapper.writeValueAsString(result));
    }
}
```

### 5.8 处理器

#### 5.8.1 安全异常处理器

创建 `src/main/java/top/mqxu/api/common/handler/SecurityExceptionHandler.java`：

```java
package top.mqxu.api.common.handler;

import com.fasterxml.jackson.databind.ObjectMapper;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import lombok.extern.slf4j.Slf4j;
import org.springframework.http.MediaType;
import org.springframework.security.core.AuthenticationException;
import org.springframework.security.web.AuthenticationEntryPoint;
import org.springframework.stereotype.Component;
import top.mqxu.api.common.result.Result;

import java.io.IOException;

/**
 * Security 异常处理器
 *
 * @author mqxu
 */
@Slf4j
@Component
public class SecurityExceptionHandler implements AuthenticationEntryPoint {

    private final ObjectMapper objectMapper;

    public SecurityExceptionHandler(ObjectMapper objectMapper) {
        this.objectMapper = objectMapper;
    }

    @Override
    public void commence(HttpServletRequest request, HttpServletResponse response, AuthenticationException authException) throws IOException {
        log.error("认证异常: {}", authException.getMessage());

        response.setContentType(MediaType.APPLICATION_JSON_VALUE);
        response.setCharacterEncoding("UTF-8");
        response.setStatus(HttpServletResponse.SC_UNAUTHORIZED);

        Result<Object> result = Result.fail(401, "未登录，请先登录");
        response.getWriter().write(objectMapper.writeValueAsString(result));
    }
}
```

---

## 6. 配置类

配置类包含 Spring Boot 的各种配置，如 MyBatis-Plus、Redis、Security 等。

### 6.1 MyBatis-Plus 配置

创建 `src/main/java/top/mqxu/api/config/MyBatisPlusConfig.java`：

```java
package top.mqxu.api.config;

import com.baomidou.mybatisplus.annotation.DbType;
import com.baomidou.mybatisplus.core.handlers.MetaObjectHandler;
import com.baomidou.mybatisplus.extension.plugins.MybatisPlusInterceptor;
import com.baomidou.mybatisplus.extension.plugins.inner.BlockAttackInnerInterceptor;
import com.baomidou.mybatisplus.extension.plugins.inner.OptimisticLockerInnerInterceptor;
import com.baomidou.mybatisplus.extension.plugins.inner.PaginationInnerInterceptor;
import org.apache.ibatis.reflection.MetaObject;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

import java.time.LocalDateTime;

/**
 * MyBatis-Plus 配置
 *
 * @author mqxu
 */
@Configuration
public class MyBatisPlusConfig {

    /**
     * MyBatis-Plus 拦截器配置
     */
    @Bean
    public MybatisPlusInterceptor mybatisPlusInterceptor() {
        MybatisPlusInterceptor interceptor = new MybatisPlusInterceptor();
        // 分页插件
        interceptor.addInnerInterceptor(new PaginationInnerInterceptor(DbType.MYSQL));
        // 乐观锁插件
        interceptor.addInnerInterceptor(new OptimisticLockerInnerInterceptor());
        // 防止全表更新和删除
        interceptor.addInnerInterceptor(new BlockAttackInnerInterceptor());
        return interceptor;
    }

    /**
     * 元数据自动填充处理器
     */
    @Bean
    public MetaObjectHandler metaObjectHandler() {
        return new MetaObjectHandler() {
            @Override
            public void insertFill(MetaObject metaObject) {
                this.strictInsertFill(metaObject, "createTime", LocalDateTime.class, LocalDateTime.now());
                this.strictInsertFill(metaObject, "updateTime", LocalDateTime.class, LocalDateTime.now());
                this.strictInsertFill(metaObject, "deleted", Integer.class, 0);
            }

            @Override
            public void updateFill(MetaObject metaObject) {
                this.strictUpdateFill(metaObject, "updateTime", LocalDateTime.class, LocalDateTime.now());
            }
        };
    }
}
```

### 6.2 Redis 配置

创建 `src/main/java/top/mqxu/api/config/RedisConfig.java`：

```java
package top.mqxu.api.config;

import com.fasterxml.jackson.annotation.JsonAutoDetect;
import com.fasterxml.jackson.annotation.PropertyAccessor;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.jsontype.impl.LaissezFaireSubTypeValidator;
import com.fasterxml.jackson.datatype.jsr310.JavaTimeModule;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.data.redis.connection.RedisConnectionFactory;
import org.springframework.data.redis.core.RedisTemplate;
import org.springframework.data.redis.serializer.Jackson2JsonRedisSerializer;
import org.springframework.data.redis.serializer.StringRedisSerializer;

/**
 * Redis 配置
 *
 * @author mqxu
 */
@Configuration
public class RedisConfig {

    @Bean
    public RedisTemplate<String, Object> redisTemplate(RedisConnectionFactory connectionFactory) {
        RedisTemplate<String, Object> template = new RedisTemplate<>();
        template.setConnectionFactory(connectionFactory);

        // 使用 Jackson2JsonRedisSerializer 来序列化和反序列化 redis 的 value 值
        Jackson2JsonRedisSerializer<Object> serializer = new Jackson2JsonRedisSerializer<>(Object.class);

        ObjectMapper mapper = new ObjectMapper();
        mapper.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);
        mapper.activateDefaultTyping(LaissezFaireSubTypeValidator.instance, ObjectMapper.DefaultTyping.NON_FINAL);
        mapper.registerModule(new JavaTimeModule());
        serializer.setObjectMapper(mapper);

        // 使用 StringRedisSerializer 来序列化和反序列化 redis 的 key 值
        StringRedisSerializer stringSerializer = new StringRedisSerializer();

        // 设置 key 和 value 的序列化规则
        template.setKeySerializer(stringSerializer);
        template.setValueSerializer(serializer);
        template.setHashKeySerializer(stringSerializer);
        template.setHashValueSerializer(serializer);

        template.afterPropertiesSet();
        return template;
    }
}
```

### 6.3 Jackson 配置

创建 `src/main/java/top/mqxu/api/config/JacksonConfig.java`：

```java
package top.mqxu.api.config;

import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.SerializationFeature;
import com.fasterxml.jackson.datatype.jsr310.JavaTimeModule;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.context.annotation.Primary;

/**
 * Jackson 配置
 *
 * @author mqxu
 */
@Configuration
public class JacksonConfig {

    @Bean
    @Primary
    public ObjectMapper objectMapper() {
        ObjectMapper mapper = new ObjectMapper();

        // 注册 Java 8 时间模块
        mapper.registerModule(new JavaTimeModule());

        // 禁用将日期写为时间戳
        mapper.disable(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS);

        return mapper;
    }
}
```

### 6.4 Knife4j 配置

创建 `src/main/java/top/mqxu/api/config/Knife4jConfig.java`：

```java
package top.mqxu.api.config;

import io.swagger.v3.oas.models.OpenAPI;
import io.swagger.v3.oas.models.info.Info;
import io.swagger.v3.oas.models.info.License;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

/**
 * Knife4j 配置
 *
 * @author mqxu
 */
@Configuration
public class Knife4jConfig {

    @Bean
    public OpenAPI openAPI() {
        return new OpenAPI()
                .info(new Info()
                        .title("API Template 接口文档")
                        .description("Spring Boot API 项目脚手架接口文档")
                        .version("1.0.0")
                        .license(new License()
                                .name("Apache 2.0")
                                .url("https://www.apache.org/licenses/LICENSE-2.0")));
    }
}
```

### 6.5 Spring Security 配置

创建 `src/main/java/top/mqxu/api/config/SecurityConfig.java`：

```java
package top.mqxu.api.config;

import lombok.RequiredArgsConstructor;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.authentication.AuthenticationManager;
import org.springframework.security.authentication.AuthenticationProvider;
import org.springframework.security.authentication.dao.DaoAuthenticationProvider;
import org.springframework.security.config.annotation.authentication.configuration.AuthenticationConfiguration;
import org.springframework.security.config.annotation.method.configuration.EnableMethodSecurity;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
import org.springframework.security.config.annotation.web.configurers.AbstractHttpConfigurer;
import org.springframework.security.config.http.SessionCreationPolicy;
import org.springframework.security.core.userdetails.UserDetailsService;
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.security.web.SecurityFilterChain;
import org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter;
import top.mqxu.api.common.filter.JwtAuthenticationFilter;
import top.mqxu.api.common.handler.SecurityExceptionHandler;

/**
 * Spring Security 配置
 *
 * @author mqxu
 */
@Configuration
@EnableWebSecurity
@EnableMethodSecurity
@RequiredArgsConstructor
public class SecurityConfig {

    private final JwtAuthenticationFilter jwtAuthenticationFilter;
    private final UserDetailsService userDetailsService;
    private final SecurityExceptionHandler securityExceptionHandler;

    /**
     * 密码编码器
     */
    @Bean
    public PasswordEncoder passwordEncoder() {
        return new BCryptPasswordEncoder();
    }

    /**
     * 认证提供者
     */
    @Bean
    public AuthenticationProvider authenticationProvider() {
        DaoAuthenticationProvider authProvider = new DaoAuthenticationProvider();
        authProvider.setUserDetailsService(userDetailsService);
        authProvider.setPasswordEncoder(passwordEncoder());
        return authProvider;
    }

    /**
     * 认证管理器
     */
    @Bean
    public AuthenticationManager authenticationManager(AuthenticationConfiguration config) throws Exception {
        return config.getAuthenticationManager();
    }

    /**
     * 安全过滤器链
     */
    @Bean
    public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {
        http
                // 禁用 CSRF
                .csrf(AbstractHttpConfigurer::disable)

                // 设置会话管理为无状态
                .sessionManagement(session -> session.sessionCreationPolicy(SessionCreationPolicy.STATELESS))

                // 设置认证提供者
                .authenticationProvider(authenticationProvider())

                // 添加 JWT 过滤器
                .addFilterBefore(jwtAuthenticationFilter, UsernamePasswordAuthenticationFilter.class)

                // 异常处理
                .exceptionHandling(exception -> exception.authenticationEntryPoint(securityExceptionHandler))

                // 请求授权配置
                .authorizeHttpRequests(auth -> auth
                        // 允许访问的接口
                        .requestMatchers("/api/auth/**").permitAll()
                        .requestMatchers("/doc.html", "/webjars/**", "/swagger-resources/**", "/v3/api-docs/**").permitAll()
                        .requestMatchers("/actuator/health").permitAll()

                        // 其他所有请求都需要认证
                        .anyRequest().authenticated()
                );

        return http.build();
    }
}
```

---

## 7. 基础设施层

基础设施层包含第三方服务集成，如短信服务、对象存储、微信服务等。

### 7.1 短信服务

#### 7.1.1 短信配置属性

创建 `src/main/java/top/mqxu/api/infrastructure/sms/RongLianSmsProperties.java`：

```java
package top.mqxu.api.infrastructure.sms;

import lombok.Data;
import org.springframework.boot.context.properties.ConfigurationProperties;
import org.springframework.stereotype.Component;

/**
 * 容联云短信配置属性
 *
 * @author mqxu
 */
@Data
@Component
@ConfigurationProperties(prefix = "ronglian")
public class RongLianSmsProperties {
    /**
     * 服务器地址
     */
    private String server;

    /**
     * 服务器端口
     */
    private String port;

    /**
     * 账户 SID
     */
    private String accountSid;

    /**
     * 认证令牌
     */
    private String authToken;

    /**
     * 应用 ID
     */
    private String appId;

    /**
     * 模板 ID
     */
    private String templateId;

    /**
     * REST URL
     */
    private String restUrl;
}
```

#### 7.1.2 短信服务接口

创建 `src/main/java/top/mqxu/api/infrastructure/sms/SmsProvider.java`：

```java
package top.mqxu.api.infrastructure.sms;

/**
 * 短信服务提供者接口
 *
 * @author mqxu
 */
public interface SmsProvider {

    /**
     * 发送短信验证码
     *
     * @param mobile 手机号
     * @param code   验证码
     * @return 发送结果
     */
    boolean sendSmsCode(String mobile, String code);
}
```

#### 7.1.3 容联云短信服务实现

创建 `src/main/java/top/mqxu/api/infrastructure/sms/impl/RongLianSmsServiceImpl.java`：

```java
package top.mqxu.api.infrastructure.sms.impl;

import cn.hutool.core.util.RandomUtil;
import cn.hutool.crypto.digest.HMac;
import cn.hutool.crypto.digest.HmacAlgorithm;
import cn.hutool.http.HttpRequest;
import cn.hutool.http.HttpResponse;
import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.ObjectMapper;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Service;
import top.mqxu.api.infrastructure.sms.RongLianSmsProperties;
import top.mqxu.api.infrastructure.sms.SmsProvider;

import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;
import java.util.HashMap;
import java.util.Map;

/**
 * 容联云短信服务实现
 *
 * @author mqxu
 */
@Slf4j
@Service
@RequiredArgsConstructor
public class RongLianSmsServiceImpl implements SmsProvider {

    private final RongLianSmsProperties properties;
    private final ObjectMapper objectMapper;

    @Override
    public boolean sendSmsCode(String mobile, String code) {
        try {
            // 生成时间戳
            String timestamp = LocalDateTime.now().format(DateTimeFormatter.ofPattern("yyyyMMddHHmmss"));

            // 生成签名
            String sig = calculateSignature(timestamp);

            // 构建请求参数
            Map<String, Object> params = new HashMap<>();
            params.put("accountSid", properties.getAccountSid());
            params.put("templateid", properties.getTemplateId());
            params.put("param", code);
            params.put("to", mobile);
            params.put("timestamp", timestamp);
            params.put("sig", sig);
            params.put("respDataType", "JSON");

            // 发送请求
            String url = properties.getRestUrl() + "/2013-12-26/Accounts/" + properties.getAccountSid() + "/SMS/TemplateSMS";
            HttpResponse response = HttpRequest.post(url)
                    .form(params)
                    .timeout(10000)
                    .execute();

            // 解析响应
            String body = response.body();
            JsonNode jsonNode = objectMapper.readTree(body);

            if ("000000".equals(jsonNode.get("statusCode").asText())) {
                log.info("短信验证码发送成功，手机号：{}", mobile);
                return true;
            } else {
                log.error("短信验证码发送失败，手机号：{}，错误信息：{}", mobile, jsonNode.get("statusMsg").asText());
                return false;
            }
        } catch (Exception e) {
            log.error("短信验证码发送异常，手机号：{}", mobile, e);
            return false;
        }
    }

    /**
     * 计算签名
     */
    private String calculateSignature(String timestamp) {
        String data = properties.getAccountSid() + properties.getAuthToken() + timestamp;
        HMac hmac = new HMac(HmacAlgorithm.HmacSHA1, properties.getAuthToken().getBytes());
        return hmac.digestHex(data).toUpperCase();
    }
}
```

### 7.2 对象存储服务

#### 7.2.1 OSS 配置属性

创建 `src/main/java/top/mqxu/api/infrastructure/oss/AliyunOssProperties.java`：

```java
package top.mqxu.api.infrastructure.oss;

import lombok.Data;
import org.springframework.boot.context.properties.ConfigurationProperties;
import org.springframework.stereotype.Component;

/**
 * 阿里云 OSS 配置属性
 *
 * @author mqxu
 */
@Data
@Component
@ConfigurationProperties(prefix = "aliyun.oss")
public class AliyunOssProperties {
    /**
     * Endpoint
     */
    private String endpoint;

    /**
     * Access Key
     */
    private String accessKey;

    /**
     * Access Secret
     */
    private String accessSecret;

    /**
     * Bucket 名称
     */
    private String bucket;

    /**
     * 访问域名
     */
    private String host;
}
```

#### 7.2.2 OSS 服务接口

创建 `src/main/java/top/mqxu/api/infrastructure/oss/OssService.java`：

```java
package top.mqxu.api.infrastructure.oss;

import org.springframework.web.multipart.MultipartFile;

/**
 * OSS 服务接口
 *
 * @author mqxu
 */
public interface OssService {

    /**
     * 上传文件
     *
     * @param file 文件
     * @return 文件 URL
     */
    String uploadFile(MultipartFile file);

    /**
     * 删除文件
     *
     * @param objectName 对象名称
     * @return 删除结果
     */
    boolean deleteFile(String objectName);
}
```

#### 7.2.3 阿里云 OSS 服务实现

创建 `src/main/java/top/mqxu/api/infrastructure/oss/impl/AliyunOssServiceImpl.java`：

```java
package top.mqxu.api.infrastructure.oss.impl;

import com.aliyun.oss.OSS;
import com.aliyun.oss.OSSClientBuilder;
import com.aliyun.oss.model.ObjectMetadata;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Service;
import org.springframework.web.multipart.MultipartFile;
import top.mqxu.api.infrastructure.oss.AliyunOssProperties;
import top.mqxu.api.infrastructure.oss.OssService;

import java.io.IOException;
import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;
import java.util.UUID;

/**
 * 阿里云 OSS 服务实现
 *
 * @author mqxu
 */
@Slf4j
@Service
@RequiredArgsConstructor
public class AliyunOssServiceImpl implements OssService {

    private final AliyunOssProperties properties;

    @Override
    public String uploadFile(MultipartFile file) {
        try {
            // 创建 OSS 客户端
            OSS ossClient = new OSSClientBuilder().build(
                    properties.getEndpoint(),
                    properties.getAccessKey(),
                    properties.getAccessSecret()
            );

            // 生成文件名
            String originalFilename = file.getOriginalFilename();
            String extension = originalFilename != null ? originalFilename.substring(originalFilename.lastIndexOf(".")) : "";
            String objectName = generateObjectName(extension);

            // 设置文件元信息
            ObjectMetadata metadata = new ObjectMetadata();
            metadata.setContentLength(file.getSize());
            metadata.setContentType(file.getContentType());

            // 上传文件
            ossClient.putObject(properties.getBucket(), objectName, file.getInputStream(), metadata);

            // 关闭客户端
            ossClient.shutdown();

            // 返回文件 URL
            return properties.getHost() + "/" + objectName;
        } catch (IOException e) {
            log.error("文件上传失败", e);
            throw new RuntimeException("文件上传失败");
        }
    }

    @Override
    public boolean deleteFile(String objectName) {
        try {
            // 创建 OSS 客户端
            OSS ossClient = new OSSClientBuilder().build(
                    properties.getEndpoint(),
                    properties.getAccessKey(),
                    properties.getAccessSecret()
            );

            // 删除文件
            ossClient.deleteObject(properties.getBucket(), objectName);

            // 关闭客户端
            ossClient.shutdown();

            return true;
        } catch (Exception e) {
            log.error("文件删除失败，对象名称：{}", objectName, e);
            return false;
        }
    }

    /**
     * 生成对象名称
     */
    private String generateObjectName(String extension) {
        String date = LocalDateTime.now().format(DateTimeFormatter.ofPattern("yyyy/MM/dd"));
        String uuid = UUID.randomUUID().toString().replace("-", "");
        return String.format("uploads/%s/%s%s", date, uuid, extension);
    }
}
```

### 7.3 微信服务

#### 7.3.1 微信配置属性

创建 `src/main/java/top/mqxu/api/infrastructure/wechat/WechatProperties.java`：

```java
package top.mqxu.api.infrastructure.wechat;

import lombok.Data;
import org.springframework.boot.context.properties.ConfigurationProperties;
import org.springframework.stereotype.Component;

/**
 * 微信配置属性
 *
 * @author mqxu
 */
@Data
@Component
@ConfigurationProperties(prefix = "wechat")
public class WechatProperties {
    /**
     * API URL
     */
    private String url;

    /**
     * App ID
     */
    private String appId;

    /**
     * App Secret
     */
    private String appSecret;
}
```

#### 7.3.2 微信用户信息

创建 `src/main/java/top/mqxu/api/infrastructure/wechat/WechatUserInfo.java`：

```java
package top.mqxu.api.infrastructure.wechat;

import lombok.Data;

/**
 * 微信用户信息
 *
 * @author mqxu
 */
@Data
public class WechatUserInfo {
    /**
     * OpenID
     */
    private String openid;

    /**
     * 会话密钥
     */
    private String session_key;

    /**
     * UnionID（可选）
     */
    private String unionid;

    /**
     * 错误码
     */
    private Integer errcode;

    /**
     * 错误信息
     */
    private String errmsg;
}
```

#### 7.3.3 微信服务接口

创建 `src/main/java/top/mqxu/api/infrastructure/wechat/WechatService.java`：

```java
package top.mqxu.api.infrastructure.wechat;

/**
 * 微信服务接口
 *
 * @author mqxu
 */
public interface WechatService {

    /**
     * 通过 code 获取微信用户信息
     *
     * @param code 授权码
     * @return 微信用户信息
     */
    WechatUserInfo getUserInfo(String code);
}
```

#### 7.3.4 微信服务实现

创建 `src/main/java/top/mqxu/api/infrastructure/wechat/impl/WechatServiceImpl.java`：

```java
package top.mqxu.api.infrastructure.wechat.impl;

import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.ObjectMapper;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Service;
import top.mqxu.api.infrastructure.wechat.WechatProperties;
import top.mqxu.api.infrastructure.wechat.WechatService;
import top.mqxu.api.infrastructure.wechat.WechatUserInfo;

/**
 * 微信服务实现
 *
 * @author mqxu
 */
@Slf4j
@Service
@RequiredArgsConstructor
public class WechatServiceImpl implements WechatService {

    private final WechatProperties properties;
    private final ObjectMapper objectMapper;

    @Override
    public WechatUserInfo getUserInfo(String code) {
        try {
            // 构建请求 URL
            String url = String.format("%s?appid=%s&secret=%s&js_code=%s&grant_type=authorization_code",
                    properties.getUrl(),
                    properties.getAppId(),
                    properties.getAppSecret(),
                    code);

            // 发送 HTTP 请求
            cn.hutool.http.HttpResponse response = cn.hutool.http.HttpRequest.get(url)
                    .timeout(10000)
                    .execute();

            // 解析响应
            String body = response.body();
            JsonNode jsonNode = objectMapper.readTree(body);

            WechatUserInfo userInfo = new WechatUserInfo();

            // 检查是否有错误
            if (jsonNode.has("errcode")) {
                userInfo.setErrcode(jsonNode.get("errcode").asInt());
                userInfo.setErrmsg(jsonNode.get("errmsg").asText());
                log.error("获取微信用户信息失败：{}", userInfo.getErrmsg());
                return userInfo;
            }

            // 设置用户信息
            userInfo.setOpenid(jsonNode.get("openid").asText());
            userInfo.setSession_key(jsonNode.get("session_key").asText());

            if (jsonNode.has("unionid")) {
                userInfo.setUnionid(jsonNode.get("unionid").asText());
            }

            return userInfo;
        } catch (Exception e) {
            log.error("获取微信用户信息异常", e);
            WechatUserInfo userInfo = new WechatUserInfo();
            userInfo.setErrcode(-1);
            userInfo.setErrmsg("系统异常");
            return userInfo;
        }
    }
}
```

---

## 8. 认证模块

认证模块负责用户登录、注册、认证等功能。

### 8.1 DTO（数据传输对象）

#### 8.1.1 登录 DTO

创建 `src/main/java/top/mqxu/api/module/auth/model/dto/LoginDTO.java`：

```java
package top.mqxu.api.module.auth.model.dto;

import io.swagger.v3.oas.annotations.media.Schema;
import jakarta.validation.constraints.NotBlank;
import lombok.Data;

/**
 * 登录请求 DTO
 *
 * @author mqxu
 */
@Data
@Schema(description = "登录请求")
public class LoginDTO {

    @NotBlank(message = "用户名不能为空")
    @Schema(description = "用户名", example = "admin")
    private String username;

    @NotBlank(message = "密码不能为空")
    @Schema(description = "密码", example = "123456")
    private String password;
}
```

#### 8.1.2 短信登录 DTO

创建 `src/main/java/top/mqxu/api/module/auth/model/dto/SmsLoginDTO.java`：

```java
package top.mqxu.api.module.auth.model.dto;

import io.swagger.v3.oas.annotations.media.Schema;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.Pattern;
import lombok.Data;

/**
 * 短信登录 DTO
 *
 * @author mqxu
 */
@Data
@Schema(description = "短信登录请求")
public class SmsLoginDTO {

    @NotBlank(message = "手机号不能为空")
    @Pattern(regexp = "^1[3-9]\\d{9}$", message = "手机号格式不正确")
    @Schema(description = "手机号", example = "13800138000")
    private String mobile;

    @NotBlank(message = "验证码不能为空")
    @Pattern(regexp = "^\\d{6}$", message = "验证码格式不正确")
    @Schema(description = "验证码", example = "123456")
    private String code;
}
```

#### 8.1.3 微信登录 DTO

创建 `src/main/java/top/mqxu/api/module/auth/model/dto/WechatLoginDTO.java`：

```java
package top.mqxu.api.module.auth.model.dto;

import io.swagger.v3.oas.annotations.media.Schema;
import jakarta.validation.constraints.NotBlank;
import lombok.Data;

/**
 * 微信登录 DTO
 *
 * @author mqxu
 */
@Data
@Schema(description = "微信登录请求")
public class WechatLoginDTO {

    @NotBlank(message = "授权码不能为空")
    @Schema(description = "微信授权码", example = "wx_code")
    private String code;
}
```

#### 8.1.4 绑定手机号 DTO

创建 `src/main/java/top/mqxu/api/module/auth/model/dto/BindMobileDTO.java`：

```java
package top.mqxu.api.module.auth.model.dto;

import io.swagger.v3.oas.annotations.media.Schema;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.Pattern;
import lombok.Data;

/**
 * 绑定手机号 DTO
 *
 * @author mqxu
 */
@Data
@Schema(description = "绑定手机号请求")
public class BindMobileDTO {

    @NotBlank(message = "手机号不能为空")
    @Pattern(regexp = "^1[3-9]\\d{9}$", message = "手机号格式不正确")
    @Schema(description = "手机号", example = "13800138000")
    private String mobile;

    @NotBlank(message = "验证码不能为空")
    @Pattern(regexp = "^\\d{6}$", message = "验证码格式不正确")
    @Schema(description = "验证码", example = "123456")
    private String code;
}
```

#### 8.1.5 换绑手机号 DTO

创建 `src/main/java/top/mqxu/api/module/auth/model/dto/ChangeMobileDTO.java`：

```java
package top.mqxu.api.module.auth.model.dto;

import io.swagger.v3.oas.annotations.media.Schema;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.Pattern;
import lombok.Data;

/**
 * 换绑手机号 DTO
 *
 * @author mqxu
 */
@Data
@Schema(description = "换绑手机号请求")
public class ChangeMobileDTO {

    @NotBlank(message = "原手机号不能为空")
    @Pattern(regexp = "^1[3-9]\\d{9}$", message = "原手机号格式不正确")
    @Schema(description = "原手机号", example = "13800138000")
    private String oldMobile;

    @NotBlank(message = "原手机验证码不能为空")
    @Pattern(regexp = "^\\d{6}$", message = "原手机验证码格式不正确")
    @Schema(description = "原手机验证码", example = "123456")
    private String oldCode;

    @NotBlank(message = "新手机号不能为空")
    @Pattern(regexp = "^1[3-9]\\d{9}$", message = "新手机号格式不正确")
    @Schema(description = "新手机号", example = "13900139000")
    private String newMobile;

    @NotBlank(message = "新手机验证码不能为空")
    @Pattern(regexp = "^\\d{6}$", message = "新手机验证码格式不正确")
    @Schema(description = "新手机验证码", example = "654321")
    private String newCode;
}
```

### 8.2 VO（视图对象）

#### 8.2.1 Token VO

创建 `src/main/java/top/mqxu/api/module/auth/model/vo/TokenVO.java`：

```java
package top.mqxu.api.module.auth.model.vo;

import io.swagger.v3.oas.annotations.media.Schema;
import lombok.Data;

/**
 * Token 响应 VO
 *
 * @author mqxu
 */
@Data
@Schema(description = "Token 响应")
public class TokenVO {

    @Schema(description = "访问令牌")
    private String token;

    @Schema(description = "令牌类型", example = "Bearer")
    private String tokenType = "Bearer";

    @Schema(description = "过期时间（秒）")
    private Long expiresIn;
}
```

### 8.3 服务层

#### 8.3.1 认证服务接口

创建 `src/main/java/top/mqxu/api/module/auth/service/AuthService.java`：

```java
package top.mqxu.api.module.auth.service;

import top.mqxu.api.module.auth.model.dto.*;
import top.mqxu.api.module.auth.model.vo.TokenVO;

/**
 * 认证服务接口
 *
 * @author mqxu
 */
public interface AuthService {

    /**
     * 用户名密码登录
     *
     * @param dto 登录请求
     * @return Token 信息
     */
    TokenVO login(LoginDTO dto);

    /**
     * 发送短信验证码
     *
     * @param mobile 手机号
     */
    void sendSmsCode(String mobile);

    /**
     * 短信验证码登录
     *
     * @param dto 短信登录请求
     * @return Token 信息
     */
    TokenVO smsLogin(SmsLoginDTO dto);

    /**
     * 微信登录
     *
     * @param dto 微信登录请求
     * @return Token 信息
     */
    TokenVO wechatLogin(WechatLoginDTO dto);

    /**
     * 用户登出
     *
     * @param userId 用户ID
     */
    void logoutByUserId(Long userId);

    /**
     * 绑定手机号
     *
     * @param mobile 手机号
     * @param code   验证码
     * @param userId 用户ID
     */
    void bindMobile(String mobile, String code, Long userId);

    /**
     * 换绑手机号
     *
     * @param oldMobile 原手机号
     * @param oldCode   原手机验证码
     * @param newMobile 新手机号
     * @param newCode   新手机验证码
     * @param userId    用户ID
     */
    void changeMobile(String oldMobile, String oldCode, String newMobile, String newCode, Long userId);
}
```

#### 8.3.2 认证服务实现

创建 `src/main/java/top/mqxu/api/module/auth/service/impl/AuthServiceImpl.java`：

```java
package top.mqxu.api.module.auth.service.impl;

import cn.hutool.core.util.RandomUtil;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.security.authentication.AuthenticationManager;
import org.springframework.security.authentication.BadCredentialsException;
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.AuthenticationException;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.security.core.userdetails.UserDetailsService;
import org.springframework.security.core.userdetails.UsernameNotFoundException;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.stereotype.Service;
import top.mqxu.api.common.cache.RedisCache;
import top.mqxu.api.common.cache.RedisKeys;
import top.mqxu.api.common.exception.ServerException;
import top.mqxu.api.common.result.ResultCode;
import top.mqxu.api.common.utils.JwtUtils;
import top.mqxu.api.infrastructure.sms.SmsProvider;
import top.mqxu.api.infrastructure.wechat.WechatService;
import top.mqxu.api.infrastructure.wechat.WechatUserInfo;
import top.mqxu.api.module.auth.model.dto.*;
import top.mqxu.api.module.auth.model.vo.TokenVO;
import top.mqxu.api.module.auth.service.AuthService;
import top.mqxu.api.module.user.model.entity.UserEntity;
import top.mqxu.api.module.user.model.enums.GenderEnum;
import top.mqxu.api.module.user.model.enums.StatusEnum;
import top.mqxu.api.module.user.service.UserService;

import java.time.LocalDateTime;
import java.util.concurrent.TimeUnit;

/**
 * 认证服务实现
 *
 * @author mqxu
 */
@Slf4j
@Service
@RequiredArgsConstructor
public class AuthServiceImpl implements AuthService {

    private final AuthenticationManager authenticationManager;
    private final UserDetailsService userDetailsService;
    private final PasswordEncoder passwordEncoder;
    private final JwtUtils jwtUtils;
    private final RedisCache redisCache;
    private final SmsProvider smsProvider;
    private final WechatService wechatService;
    private final UserService userService;

    @Override
    public TokenVO login(LoginDTO dto) {
        try {
            // 认证用户
            Authentication authentication = authenticationManager.authenticate(
                    new UsernamePasswordAuthenticationToken(dto.getUsername(), dto.getPassword())
            );

            // 生成 Token
            UserDetails userDetails = (UserDetails) authentication.getPrincipal();
            Long userId = Long.parseLong(userDetails.getUsername());
            String token = jwtUtils.generateToken(userId);

            // 缓存用户信息
            cacheUserInfo(userId);

            return buildTokenVO(token);
        } catch (AuthenticationException e) {
            throw new ServerException(ResultCode.UNAUTHORIZED.getCode(), "用户名或密码错误");
        }
    }

    @Override
    public void sendSmsCode(String mobile) {
        // 生成 6 位数字验证码
        String code = RandomUtil.randomNumbers(6);

        // 缓存验证码（5 分钟过期）
        redisCache.set(RedisKeys.SMS_CODE + mobile, code, 5, TimeUnit.MINUTES);

        // 发送短信
        boolean success = smsProvider.sendSmsCode(mobile, code);
        if (!success) {
            throw new ServerException("短信发送失败，请稍后重试");
        }

        log.info("短信验证码已发送，手机号：{}，验证码：{}", mobile, code);
    }

    @Override
    public TokenVO smsLogin(SmsLoginDTO dto) {
        // 验证短信验证码
        String cacheKey = RedisKeys.SMS_CODE + dto.getMobile();
        Object cacheCode = redisCache.get(cacheKey);

        if (cacheCode == null) {
            throw new ServerException("验证码已过期，请重新获取");
        }

        if (!dto.getCode().equals(cacheCode.toString())) {
            throw new ServerException("验证码错误");
        }

        // 删除验证码缓存
        redisCache.delete(cacheKey);

        // 查询或创建用户
        UserEntity user = userService.getUserByMobile(dto.getMobile());
        if (user == null) {
            // 自动注册用户
            user = new UserEntity();
            user.setMobile(dto.getMobile());
            user.setNickname("用户" + dto.getMobile().substring(7));
            user.setStatus(StatusEnum.NORMAL.getCode());
            user.setGender(GenderEnum.UNKNOWN.getCode());
            userService.save(user);
        } else if (StatusEnum.DISABLED.getCode().equals(user.getStatus())) {
            throw new ServerException("账户已被禁用");
        }

        // 生成 Token
        String token = jwtUtils.generateToken(user.getId());

        // 缓存用户信息
        cacheUserInfo(user.getId());

        return buildTokenVO(token);
    }

    @Override
    public TokenVO wechatLogin(WechatLoginDTO dto) {
        // 获取微信用户信息
        WechatUserInfo wechatUser = wechatService.getUserInfo(dto.getCode());

        if (wechatUser.getErrcode() != null && wechatUser.getErrcode() != 0) {
            throw new ServerException("微信登录失败：" + wechatUser.getErrmsg());
        }

        // 查询或创建用户
        UserEntity user = userService.getUserByWxOpenid(wechatUser.getOpenid());
        if (user == null) {
            // 自动注册用户
            user = new UserEntity();
            user.setWxOpenid(wechatUser.getOpenid());
            user.setNickname("微信用户" + RandomUtil.randomString(6));
            user.setStatus(StatusEnum.NORMAL.getCode());
            user.setGender(GenderEnum.UNKNOWN.getCode());
            userService.save(user);
        } else if (StatusEnum.DISABLED.getCode().equals(user.getStatus())) {
            throw new ServerException("账户已被禁用");
        }

        // 生成 Token
        String token = jwtUtils.generateToken(user.getId());

        // 缓存用户信息
        cacheUserInfo(user.getId());

        return buildTokenVO(token);
    }

    @Override
    public void logoutByUserId(Long userId) {
        // 获取当前 Token（这里简化处理，实际应该从请求头中获取）
        // 将 Token 加入黑名单
        // String token = getCurrentToken();
        // redisCache.set(RedisKeys.JWT_BLACKLIST + token, "1", jwtUtils.getExpiration(token) - System.currentTimeMillis(), TimeUnit.MILLISECONDS);

        // 清除用户信息缓存
        redisCache.delete(RedisKeys.USER_INFO + userId);
        redisCache.delete(RedisKeys.USER_PERMISSIONS + userId);
    }

    @Override
    public void bindMobile(String mobile, String code, Long userId) {
        // 验证短信验证码
        String cacheKey = RedisKeys.SMS_CODE + mobile;
        Object cacheCode = redisCache.get(cacheKey);

        if (cacheCode == null) {
            throw new ServerException("验证码已过期，请重新获取");
        }

        if (!code.equals(cacheCode.toString())) {
            throw new ServerException("验证码错误");
        }

        // 删除验证码缓存
        redisCache.delete(cacheKey);

        // 检查手机号是否已被绑定
        UserEntity existUser = userService.getUserByMobile(mobile);
        if (existUser != null) {
            throw new ServerException("该手机号已被其他用户绑定");
        }

        // 绑定手机号
        UserEntity user = userService.getById(userId);
        if (user == null) {
            throw new ServerException("用户不存在");
        }

        user.setMobile(mobile);
        userService.updateById(user);
    }

    @Override
    public void changeMobile(String oldMobile, String oldCode, String newMobile, String newCode, Long userId) {
        // 验证原手机号验证码
        String oldCacheKey = RedisKeys.SMS_CODE + oldMobile;
        Object oldCacheCode = redisCache.get(oldCacheKey);

        if (oldCacheCode == null) {
            throw new ServerException("原手机验证码已过期，请重新获取");
        }

        if (!oldCode.equals(oldCacheCode.toString())) {
            throw new ServerException("原手机验证码错误");
        }

        // 验证新手机号验证码
        String newCacheKey = RedisKeys.SMS_CODE + newMobile;
        Object newCacheCode = redisCache.get(newCacheKey);

        if (newCacheCode == null) {
            throw new ServerException("新手机验证码已过期，请重新获取");
        }

        if (!newCode.equals(newCacheCode.toString())) {
            throw new ServerException("新手机验证码错误");
        }

        // 删除验证码缓存
        redisCache.delete(oldCacheKey);
        redisCache.delete(newCacheKey);

        // 检查新手机号是否已被绑定
        UserEntity existUser = userService.getUserByMobile(newMobile);
        if (existUser != null && !existUser.getId().equals(userId)) {
            throw new ServerException("该手机号已被其他用户绑定");
        }

        // 更换手机号
        UserEntity user = userService.getById(userId);
        if (user == null) {
            throw new ServerException("用户不存在");
        }

        if (!oldMobile.equals(user.getMobile())) {
            throw new ServerException("原手机号不正确");
        }

        user.setMobile(newMobile);
        userService.updateById(user);
    }

    /**
     * 缓存用户信息
     */
    private void cacheUserInfo(Long userId) {
        UserEntity user = userService.getById(userId);
        if (user != null) {
            redisCache.set(RedisKeys.USER_INFO + userId, user, 24, TimeUnit.HOURS);
        }
    }

    /**
     * 构建 Token VO
     */
    private TokenVO buildTokenVO(String token) {
        TokenVO tokenVO = new TokenVO();
        tokenVO.setToken(token);
        tokenVO.setExpiresIn(86400L); // 24 小时
        return tokenVO;
    }
}
```

### 8.4 控制器

创建 `src/main/java/top/mqxu/api/module/auth/controller/AuthController.java`：

```java
package top.mqxu.api.module.auth.controller;

import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.Parameter;
import io.swagger.v3.oas.annotations.tags.Tag;
import jakarta.validation.constraints.Pattern;
import lombok.RequiredArgsConstructor;
import org.springframework.validation.annotation.Validated;
import org.springframework.web.bind.annotation.*;
import top.mqxu.api.common.utils.SecurityUtils;
import top.mqxu.api.common.result.Result;
import top.mqxu.api.module.auth.model.dto.*;
import top.mqxu.api.module.auth.model.vo.TokenVO;
import top.mqxu.api.module.auth.service.AuthService;

/**
 * 认证控制器
 *
 * @author mqxu
 */
@RestController
@RequestMapping("/api/auth")
@RequiredArgsConstructor
@Tag(name = "认证管理", description = "登录、登出等认证相关接口")
@Validated
public class AuthController {

    private final AuthService authService;

    @PostMapping("/login")
    @Operation(summary = "账号密码登录")
    public Result<TokenVO> login(@Validated @RequestBody LoginDTO dto) {
        TokenVO token = authService.login(dto);
        return Result.ok(token);
    }

    @PostMapping("/send-sms-code")
    @Operation(summary = "发送短信验证码")
    public Result<String> sendSmsCode(
            @Parameter(description = "手机号")
            @Pattern(regexp = "^1[3-9]\\d{9}$", message = "手机号格式不正确")
            @RequestParam String mobile) {
        authService.sendSmsCode(mobile);
        return Result.ok();
    }

    @PostMapping("/sms-login")
    @Operation(summary = "短信验证码登录")
    public Result<TokenVO> smsLogin(@Validated @RequestBody SmsLoginDTO dto) {
        TokenVO token = authService.smsLogin(dto);
        return Result.ok(token);
    }

    @PostMapping("/wechat-login")
    @Operation(summary = "微信登录")
    public Result<TokenVO> wechatLogin(@Validated @RequestBody WechatLoginDTO dto) {
        TokenVO token = authService.wechatLogin(dto);
        return Result.ok(token);
    }

    @PostMapping("/logout")
    @Operation(summary = "登出")
    public Result<String> logout() {
        Long userId = SecurityUtils.getCurrentUserId();
        authService.logoutByUserId(userId);
        return Result.ok();
    }

    @PostMapping("/bind-mobile")
    @Operation(summary = "绑定手机号")
    public Result<String> bindMobile(@Validated @RequestBody BindMobileDTO dto) {
        Long userId = SecurityUtils.getCurrentUserId();
        authService.bindMobile(dto.getMobile(), dto.getCode(), userId);
        return Result.ok();
    }

    @PostMapping("/change-mobile")
    @Operation(summary = "换绑手机号")
    public Result<String> changeMobile(@Validated @RequestBody ChangeMobileDTO dto) {
        Long userId = SecurityUtils.getCurrentUserId();
        authService.changeMobile(dto.getOldMobile(), dto.getOldCode(),
                dto.getNewMobile(), dto.getNewCode(), userId);
        return Result.ok();
    }
}
```

---

## 9. 用户模块

用户模块负责用户信息的增删改查等操作。

### 9.1 实体类

创建 `src/main/java/top/mqxu/api/module/user/model/entity/UserEntity.java`：

```java
package top.mqxu.api.module.user.model.entity;

import com.baomidou.mybatisplus.annotation.TableName;
import io.swagger.v3.oas.annotations.media.Schema;
import lombok.Data;
import lombok.EqualsAndHashCode;
import top.mqxu.api.common.entity.BaseEntity;

/**
 * 用户实体
 *
 * @author mqxu
 */
@Data
@EqualsAndHashCode(callSuper = true)
@TableName("sys_user")
@Schema(description = "用户实体")
public class UserEntity extends BaseEntity {

    /**
     * 用户名
     */
    @Schema(description = "用户名")
    private String username;

    /**
     * 密码
     */
    @Schema(description = "密码")
    private String password;

    /**
     * 真实姓名
     */
    @Schema(description = "真实姓名")
    private String realName;

    /**
     * 邮箱
     */
    @Schema(description = "邮箱")
    private String email;

    /**
     * 手机号
     */
    @Schema(description = "手机号")
    private String mobile;

    /**
     * 头像
     */
    @Schema(description = "头像")
    private String avatar;

    /**
     * 昵称
     */
    @Schema(description = "昵称")
    private String nickname;

    /**
     * 性别 0:未知 1:男 2:女
     */
    @Schema(description = "性别 0:未知 1:男 2:女")
    private Integer gender;

    /**
     * 微信 OpenID
     */
    @Schema(description = "微信 OpenID")
    private String wxOpenid;

    /**
     * 状态 0:禁用 1:正常
     */
    @Schema(description = "状态 0:禁用 1:正常")
    private Integer status;
}
```

### 9.2 DTO（数据传输对象）

创建 `src/main/java/top/mqxu/api/module/user/model/dto/UserDTO.java`：

```java
package top.mqxu.api.module.user.model.dto;

import io.swagger.v3.oas.annotations.media.Schema;
import jakarta.validation.constraints.Email;
import jakarta.validation.constraints.Pattern;
import jakarta.validation.constraints.Size;
import lombok.Data;

/**
 * 用户 DTO
 *
 * @author mqxu
 */
@Data
@Schema(description = "用户请求参数")
public class UserDTO {

    @Schema(description = "用户ID")
    private Long id;

    @Size(min = 3, max = 20, message = "用户名长度必须在 3-20 之间")
    @Pattern(regexp = "^[a-zA-Z0-9_]+$", message = "用户名只能包含字母、数字和下划线")
    @Schema(description = "用户名", example = "admin")
    private String username;

    @Size(min = 6, max = 20, message = "密码长度必须在 6-20 之间")
    @Schema(description = "密码", example = "123456")
    private String password;

    @Size(max = 50, message = "真实姓名长度不能超过 50")
    @Schema(description = "真实姓名", example = "张三")
    private String realName;

    @Email(message = "邮箱格式不正确")
    @Size(max = 100, message = "邮箱长度不能超过 100")
    @Schema(description = "邮箱", example = "zhangsan@example.com")
    private String email;

    @Pattern(regexp = "^1[3-9]\\d{9}$", message = "手机号格式不正确")
    @Schema(description = "手机号", example = "13800138000")
    private String mobile;

    @Schema(description = "头像", example = "https://example.com/avatar.jpg")
    private String avatar;

    @Size(max = 50, message = "昵称长度不能超过 50")
    @Schema(description = "昵称", example = "张三")
    private String nickname;

    @Schema(description = "性别 0:未知 1:男 2:女", example = "1")
    private Integer gender;

    @Schema(description = "状态 0:禁用 1:正常", example = "1")
    private Integer status;
}
```

### 9.3 VO（视图对象）

创建 `src/main/java/top/mqxu/api/module/user/model/vo/UserVO.java`：

```java
package top.mqxu.api.module.user.model.vo;

import io.swagger.v3.oas.annotations.media.Schema;
import lombok.Data;

import java.time.LocalDateTime;

/**
 * 用户 VO
 *
 * @author mqxu
 */
@Data
@Schema(description = "用户响应信息")
public class UserVO {

    @Schema(description = "用户ID")
    private Long id;

    @Schema(description = "用户名")
    private String username;

    @Schema(description = "真实姓名")
    private String realName;

    @Schema(description = "邮箱")
    private String email;

    @Schema(description = "手机号")
    private String mobile;

    @Schema(description = "头像")
    private String avatar;

    @Schema(description = "昵称")
    private String nickname;

    @Schema(description = "性别 0:未知 1:男 2:女")
    private Integer gender;

    @Schema(description = "状态 0:禁用 1:正常")
    private Integer status;

    @Schema(description = "创建时间")
    private LocalDateTime createTime;

    @Schema(description = "更新时间")
    private LocalDateTime updateTime;
}
```

### 9.4 Mapper

创建 `src/main/java/top/mqxu/api/module/user/mapper/UserMapper.java`：

```java
package top.mqxu.api.module.user.mapper;

import com.baomidou.mybatisplus.core.mapper.BaseMapper;
import org.apache.ibatis.annotations.Mapper;
import top.mqxu.api.module.user.model.entity.UserEntity;

/**
 * 用户 Mapper
 *
 * @author mqxu
 */
@Mapper
public interface UserMapper extends BaseMapper<UserEntity> {
}
```

### 9.5 对象转换器

创建 `src/main/java/top/mqxu/api/module/user/convert/UserConvert.java`：

```java
package top.mqxu.api.module.user.convert;

import org.mapstruct.Mapper;
import org.mapstruct.Mapping;
import org.mapstruct.factory.Mappers;
import top.mqxu.api.module.user.model.dto.UserDTO;
import top.mqxu.api.module.user.model.entity.UserEntity;
import top.mqxu.api.module.user.model.vo.UserVO;

/**
 * 用户对象转换器
 *
 * @author mqxu
 */
@Mapper(componentModel = "spring")
public interface UserConvert {

    UserConvert INSTANCE = Mappers.getMapper(UserConvert.class);

    /**
     * DTO 转 Entity
     */
    @Mapping(target = "id", ignore = true)
    @Mapping(target = "createTime", ignore = true)
    @Mapping(target = "updateTime", ignore = true)
    @Mapping(target = "deleted", ignore = true)
    UserEntity toEntity(UserDTO dto);

    /**
     * Entity 转 VO
     */
    @Mapping(target = "password", ignore = true)
    UserVO toVO(UserEntity entity);
}
```

### 9.6 服务层

#### 9.6.1 用户服务接口

创建 `src/main/java/top/mqxu/api/module/user/service/UserService.java`：

```java
package top.mqxu.api.module.user.service;

import com.baomidou.mybatisplus.extension.plugins.pagination.Page;
import top.mqxu.api.module.user.model.dto.UserDTO;
import top.mqxu.api.module.user.model.entity.UserEntity;
import top.mqxu.api.module.user.model.vo.UserVO;

/**
 * 用户服务接口
 *
 * @author mqxu
 */
public interface UserService {

    /**
     * 分页查询用户
     *
     * @param page     分页对象
     * @param username 用户名
     * @return 用户分页列表
     */
    Page<UserVO> page(Page<UserVO> page, String username);

    /**
     * 根据 ID 查询用户
     *
     * @param id 用户ID
     * @return 用户信息
     */
    UserVO getById(Long id);

    /**
     * 保存用户
     *
     * @param dto 用户信息
     */
    void save(UserDTO dto);

    /**
     * 更新个人信息
     *
     * @param dto    用户信息
     * @param userId 用户ID
     */
    void updateProfile(UserDTO dto, Long userId);

    /**
     * 根据手机号查询用户
     *
     * @param mobile 手机号
     * @return 用户信息
     */
    UserEntity getUserByMobile(String mobile);

    /**
     * 根据微信 OpenID 查询用户
     *
     * @param wxOpenid 微信 OpenID
     * @return 用户信息
     */
    UserEntity getUserByWxOpenid(String wxOpenid);
}
```

#### 9.6.2 用户服务实现

创建 `src/main/java/top/mqxu/api/module/user/service/impl/UserServiceImpl.java`：

```java
package top.mqxu.api.module.user.service.impl;

import com.baomidou.mybatisplus.core.conditions.query.LambdaQueryWrapper;
import com.baomidou.mybatisplus.extension.plugins.pagination.Page;
import lombok.RequiredArgsConstructor;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.stereotype.Service;
import org.springframework.util.StringUtils;
import top.mqxu.api.common.exception.ServerException;
import top.mqxu.api.module.user.convert.UserConvert;
import top.mqxu.api.module.user.model.dto.UserDTO;
import top.mqxu.api.module.user.model.entity.UserEntity;
import top.mqxu.api.module.user.model.enums.StatusEnum;
import top.mqxu.api.module.user.model.vo.UserVO;
import top.mqxu.api.module.user.mapper.UserMapper;
import top.mqxu.api.module.user.service.UserService;

import java.util.List;

/**
 * 用户服务实现
 *
 * @author mqxu
 */
@Service
@RequiredArgsConstructor
public class UserServiceImpl implements UserService {

    private final UserMapper userMapper;
    private final UserConvert userConvert;
    private final PasswordEncoder passwordEncoder;

    @Override
    public Page<UserVO> page(Page<UserVO> page, String username) {
        LambdaQueryWrapper<UserEntity> wrapper = new LambdaQueryWrapper<>();
        if (StringUtils.hasText(username)) {
            wrapper.like(UserEntity::getUsername, username);
        }
        wrapper.orderByDesc(UserEntity::getCreateTime);

        Page<UserEntity> entityPage = userMapper.selectPage(new Page<>(page.getCurrent(), page.getSize()), wrapper);

        List<UserVO> voList = userConvert.toVOList(entityPage.getRecords());

        page.setRecords(voList);
        page.setTotal(entityPage.getTotal());

        return page;
    }

    @Override
    public UserVO getById(Long id) {
        UserEntity entity = userMapper.selectById(id);
        if (entity == null) {
            throw new ServerException("用户不存在");
        }
        return userConvert.toVO(entity);
    }

    @Override
    public void save(UserDTO dto) {
        // 检查用户名是否已存在
        LambdaQueryWrapper<UserEntity> wrapper = new LambdaQueryWrapper<>();
        wrapper.eq(UserEntity::getUsername, dto.getUsername());
        if (userMapper.selectCount(wrapper) > 0) {
            throw new ServerException("用户名已存在");
        }

        // 检查手机号是否已存在
        if (StringUtils.hasText(dto.getMobile())) {
            wrapper.clear();
            wrapper.eq(UserEntity::getMobile, dto.getMobile());
            if (userMapper.selectCount(wrapper) > 0) {
                throw new ServerException("手机号已存在");
            }
        }

        UserEntity entity = userConvert.toEntity(dto);

        // 密码加密
        if (StringUtils.hasText(dto.getPassword())) {
            entity.setPassword(passwordEncoder.encode(dto.getPassword()));
        }

        // 设置默认状态
        if (entity.getStatus() == null) {
            entity.setStatus(StatusEnum.NORMAL.getCode());
        }

        userMapper.insert(entity);
    }

    @Override
    public void updateProfile(UserDTO dto, Long userId) {
        UserEntity entity = userMapper.selectById(userId);
        if (entity == null) {
            throw new ServerException("用户不存在");
        }

        // 更新允许修改的字段
        if (StringUtils.hasText(dto.getRealName())) {
            entity.setRealName(dto.getRealName());
        }
        if (StringUtils.hasText(dto.getEmail())) {
            entity.setEmail(dto.getEmail());
        }
        if (StringUtils.hasText(dto.getAvatar())) {
            entity.setAvatar(dto.getAvatar());
        }
        if (StringUtils.hasText(dto.getNickname())) {
            entity.setNickname(dto.getNickname());
        }
        if (dto.getGender() != null) {
            entity.setGender(dto.getGender());
        }

        userMapper.updateById(entity);
    }

    @Override
    public UserEntity getUserByMobile(String mobile) {
        LambdaQueryWrapper<UserEntity> wrapper = new LambdaQueryWrapper<>();
        wrapper.eq(UserEntity::getMobile, mobile);
        return userMapper.selectOne(wrapper);
    }

    @Override
    public UserEntity getUserByWxOpenid(String wxOpenid) {
        LambdaQueryWrapper<UserEntity> wrapper = new LambdaQueryWrapper<>();
        wrapper.eq(UserEntity::getWxOpenid, wxOpenid);
        return userMapper.selectOne(wrapper);
    }
}
```

### 9.7 控制器

创建 `src/main/java/top/mqxu/api/module/user/controller/UserController.java`：

```java
package top.mqxu.api.module.user.controller;

import com.baomidou.mybatisplus.extension.plugins.pagination.Page;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.Parameter;
import io.swagger.v3.oas.annotations.tags.Tag;
import lombok.RequiredArgsConstructor;
import org.springframework.validation.annotation.Validated;
import org.springframework.web.bind.annotation.*;
import top.mqxu.api.common.result.PageResult;
import top.mqxu.api.common.result.Result;
import top.mqxu.api.common.utils.SecurityUtils;
import top.mqxu.api.module.user.model.dto.UserDTO;
import top.mqxu.api.module.user.model.vo.UserVO;
import top.mqxu.api.module.user.service.UserService;

/**
 * 用户控制器
 *
 * @author mqxu
 */
@RestController
@RequestMapping("/api/user")
@RequiredArgsConstructor
@Tag(name = "用户管理", description = "用户管理相关接口")
public class UserController {

    private final UserService userService;

    @GetMapping("/page")
    @Operation(summary = "分页查询用户列表")
    public Result<PageResult<UserVO>> page(
            @Parameter(description = "当前页") @RequestParam(defaultValue = "1") Long current,
            @Parameter(description = "每页条数") @RequestParam(defaultValue = "10") Long size,
            @Parameter(description = "用户名") @RequestParam(required = false) String username) {
        Page<UserVO> page = new Page<>(current, size);
        page = userService.page(page, username);
        PageResult<UserVO> pageResult = new PageResult<>(page.getRecords(), page.getTotal());
        return Result.ok(pageResult);
    }

    @GetMapping("/{id}")
    @Operation(summary = "根据 ID 查询用户")
    public Result<UserVO> getById(@Parameter(description = "用户 ID") @PathVariable Long id) {
        UserVO user = userService.getById(id);
        return Result.ok(user);
    }

    @GetMapping("/user-info")
    @Operation(summary = "获取当前登录用户信息")
    public Result<UserVO> getUserInfo() {
        Long userId = SecurityUtils.getCurrentUserId();
        UserVO userInfo = userService.getById(userId);
        return Result.ok(userInfo);
    }

    @PostMapping
    @Operation(summary = "用户注册")
    public Result<String> register(@Validated @RequestBody UserDTO dto) {
        userService.save(dto);
        return Result.ok();
    }

    @PutMapping("/update-profile")
    @Operation(summary = "修改个人信息")
    public Result<String> updateProfile(@Validated @RequestBody UserDTO dto) {
        Long userId = SecurityUtils.getCurrentUserId();
        userService.updateProfile(dto, userId);
        return Result.ok();
    }
}
```

---

## 10. 启动类

创建 `src/main/java/top/mqxu/api/Application.java`：

```java
package top.mqxu.api;

import org.mybatis.spring.annotation.MapperScan;
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

/**
 * Spring Boot 启动类
 *
 * @author mqxu
 */
@SpringBootApplication
@MapperScan("top.mqxu.api.**.mapper")
public class Application {
    public static void main(String[] args) {
        SpringApplication.run(Application.class, args);
    }
}
```

---

## 11. Docker 部署

### 11.1 Dockerfile

在项目根目录创建 `Dockerfile`：

```dockerfile
# 使用多阶段构建
FROM maven:3.9.4-openjdk-17-slim AS builder

# 设置工作目录
WORKDIR /app

# 复制 pom.xml 和下载依赖
COPY pom.xml .
RUN mvn dependency:go-offline -B

# 复制源代码
COPY src ./src

# 构建应用
RUN mvn clean package -DskipTests

# 运行阶段
FROM openjdk:17-jre-slim

# 安装必要的工具
RUN apt-get update && apt-get install -y curl && rm -rf /var/lib/apt/lists/*

# 创建应用目录
WORKDIR /app

# 从构建阶段复制 jar 文件
COPY --from=builder /app/target/api-template.jar app.jar

# 创建日志目录
RUN mkdir -p /app/logs

# 暴露端口
EXPOSE 8083

# 设置 JVM 参数
ENV JAVA_OPTS="-Xms512m -Xmx1024m -XX:+UseG1GC"

# 健康检查
HEALTHCHECK --interval=30s --timeout=10s --start-period=60s --retries=3 \
  CMD curl -f http://localhost:8083/actuator/health || exit 1

# 启动应用
ENTRYPOINT ["sh", "-c", "java $JAVA_OPTS -jar app.jar"]
```

### 11.2 Docker Compose

在项目根目录创建 `docker-compose.yml`：

```yaml
version: '3.8'

services:
  # MySQL 服务
  mysql:
    image: mysql:8.0
    container_name: api-template-mysql
    restart: unless-stopped
    environment:
      MYSQL_ROOT_PASSWORD: ${MYSQL_ROOT_PASSWORD:-123456}
      MYSQL_DATABASE: ${MYSQL_DATABASE:-api_template}
      MYSQL_USER: ${MYSQL_USER:-root}
      MYSQL_PASSWORD: ${MYSQL_PASSWORD:-123456}
    ports:
      - "${MYSQL_PORT:-3306}:3306"
    volumes:
      - mysql_data:/var/lib/mysql
      - ./sql/schema.sql:/docker-entrypoint-initdb.d/schema.sql:ro
    networks:
      - api-network
    command: >
      --default-authentication-plugin=mysql_native_password
      --character-set-server=utf8mb4
      --collation-server=utf8mb4_0900_ai_ci
      --max_connections=1000
      --max_allowed_packet=128M

  # Redis 服务
  redis:
    image: redis:7-alpine
    container_name: api-template-redis
    restart: unless-stopped
    ports:
      - "${REDIS_PORT:-6379}:6379"
    volumes:
      - redis_data:/data
    networks:
      - api-network
    command: >
      redis-server
      --appendonly yes
      --maxmemory 256mb
      --maxmemory-policy allkeys-lru
    ${REDIS_PASSWORD:+--requirepass $REDIS_PASSWORD}

  # Spring Boot 应用服务
  app:
    build:
      context: .
      dockerfile: Dockerfile
    container_name: api-template-app
    restart: unless-stopped
    environment:
      # 数据库配置
      SPRING_DATASOURCE_URL: jdbc:mysql://mysql:3306/${MYSQL_DATABASE:-api_template}?useSSL=true&serverTimezone=Asia/Shanghai&characterEncoding=utf8&useUnicode=true&allowPublicKeyRetrieval=true
      SPRING_DATASOURCE_USERNAME: ${MYSQL_USER:-root}
      SPRING_DATASOURCE_PASSWORD: ${MYSQL_PASSWORD:-123456}

      # Redis 配置
      SPRING_DATA_REDIS_HOST: redis
      SPRING_DATA_REDIS_PORT: ${REDIS_PORT:-6379}
      SPRING_DATA_REDIS_PASSWORD: ${REDIS_PASSWORD:-}

      # 应用配置
      SPRING_PROFILES_ACTIVE: ${SPRING_PROFILES_ACTIVE:-prod}

      # JWT 配置
      JWT_SECRET: ${JWT_SECRET}
      JWT_EXPIRATION: ${JWT_EXPIRATION:-86400000}

      # 容联云短信配置（可选）
      RONGLIAN_SERVER: ${RONGLIAN_SERVER:-}
      RONGLIAN_PORT: ${RONGLIAN_PORT:-}
      RONGLIAN_ACCOUNT_SID: ${RONGLIAN_ACCOUNT_SID:-}
      RONGLIAN_AUTH_TOKEN: ${RONGLIAN_AUTH_TOKEN:-}
      RONGLIAN_APP_ID: ${RONGLIAN_APP_ID:-}
      RONGLIAN_TEMPLATE_ID: ${RONGLIAN_TEMPLATE_ID:-}

      # 微信配置（可选）
      WECHAT_APP_ID: ${WECHAT_APP_ID:-}
      WECHAT_APP_SECRET: ${WECHAT_APP_SECRET:-}

      # 阿里云 OSS 配置（可选）
      ALIYUN_OSS_ENDPOINT: ${ALIYUN_OSS_ENDPOINT:-}
      ALIYUN_OSS_ACCESS_KEY: ${ALIYUN_OSS_ACCESS_KEY:-}
      ALIYUN_OSS_ACCESS_SECRET: ${ALIYUN_OSS_ACCESS_SECRET:-}
      ALIYUN_OSS_BUCKET: ${ALIYUN_OSS_BUCKET:-}

      # JVM 配置
      JAVA_OPTS: ${JAVA_OPTS:--Xms512m -Xmx1024m -XX:+UseG1GC}
    ports:
      - "${APP_PORT:-8083}:8083"
    volumes:
      - app_logs:/app/logs
    networks:
      - api-network
    depends_on:
      - mysql
      - redis
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:8083/actuator/health"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 60s

# 数据卷定义
volumes:
  mysql_data:
    driver: local
  redis_data:
    driver: local
  app_logs:
    driver: local

# 网络定义
networks:
  api-network:
    driver: bridge
```

### 11.3 环境变量配置

在项目根目录创建 `.env.example`：

```bash
# 项目配置
PROJECT_NAME=api-template

# 应用端口
APP_PORT=8083

# Spring 配置
SPRING_PROFILES_ACTIVE=prod

# JVM 配置
JAVA_OPTS=-Xms512m -Xmx1024m -XX:+UseG1GC

# JWT 配置（必须设置）
JWT_SECRET=your-256-bit-secret-key-for-jwt-token-generation-min-32-chars
JWT_EXPIRATION=86400000

# MySQL 配置
MYSQL_PORT=3306
MYSQL_DATABASE=api_template
MYSQL_ROOT_PASSWORD=123456
MYSQL_USER=root
MYSQL_PASSWORD=123456

# Redis 配置
REDIS_PORT=6379
REDIS_PASSWORD=

# 容联云短信配置（可选）
RONGLIAN_SERVER=app.cloopen.com
RONGLIAN_PORT=8883
RONGLIAN_ACCOUNT_SID=your_account_sid
RONGLIAN_AUTH_TOKEN=your_auth_token
RONGLIAN_APP_ID=your_app_id
RONGLIAN_TEMPLATE_ID=1

# 微信配置（可选）
WECHAT_APP_ID=your_wechat_app_id
WECHAT_APP_SECRET=your_wechat_app_secret

# 阿里云 OSS 配置（可选）
ALIYUN_OSS_ENDPOINT=oss-cn-hangzhou.aliyuncs.com
ALIYUN_OSS_ACCESS_KEY=your_access_key
ALIYUN_OSS_ACCESS_SECRET=your_access_secret
ALIYUN_OSS_BUCKET=your_bucket_name
```

### 11.4 Git Ignore 配置

在项目根目录创建 `.gitignore`：

```gitignore
# Maven
target/
pom.xml.tag
pom.xml.releaseBackup
pom.xml.versionsBackup
pom.xml.next
release.properties
dependency-reduced-pom.xml
buildNumber.properties
.mvn/timing.properties
.mvn/wrapper/maven-wrapper.jar

# IDE
.idea/
*.iws
*.iml
*.ipr
.vscode/
!.vscode/settings.json
!.vscode/tasks.json
!.vscode/launch.json
!.vscode/extensions.json

# OS
.DS_Store
.DS_Store?
._*
.Spotlight-V100
.Trashes
ehthumbs.db
Thumbs.db

# Logs
logs/
*.log

# Environment
.env
.env.local
.env.development.local
.env.test.local
.env.production.local

# Application
application-secret.properties
```

---

## 12. 运行与测试

### 12.1 本地开发运行

#### 12.1.1 配置敏感信息

```bash
# 复制敏感配置文件模板
cp src/main/resources/application-secret.properties.example src/main/resources/application-secret.properties

# 编辑配置文件，填入实际的配置信息
nano src/main/resources/application-secret.properties
```

#### 12.1.2 启动项目

```bash
# 使用 Maven 启动
mvn spring-boot:run

# 或者使用 Maven Wrapper
./mvnw spring-boot:run

# 或者打包后启动
mvn clean package -DskipTests
java -jar target/api-template.jar
```

#### 12.1.3 访问应用

- **应用接口**: http://localhost:8083
- **API 文档**: http://localhost:8083/doc.html
- **健康检查**: http://localhost:8083/actuator/health

### 12.2 Docker 部署运行

#### 12.2.1 配置环境变量

```bash
# 复制环境变量模板
cp .env.example .env

# 编辑环境变量文件
nano .env
```

**重要配置项说明：**

1. **JWT_SECRET**（必须设置）：生成 256 位随机字符串
   ```bash
   openssl rand -base64 32
   ```

2. **数据库密码**：建议使用强密码

3. **Redis 密码**：生产环境建议设置

#### 12.2.2 启动服务

```bash
# 构建并启动所有服务
docker-compose up -d

# 查看服务状态
docker-compose ps

# 查看应用日志
docker-compose logs -f app

# 查看所有服务日志
docker-compose logs -f

# 停止服务
docker-compose down

# 停止服务并删除数据卷
docker-compose down -v

# 重新构建并启动
docker-compose up -d --build
```

### 12.3 接口测试

#### 12.3.1 账号密码登录

```bash
curl -X POST http://localhost:8083/api/auth/login \
  -H "Content-Type: application/json" \
  -d '{
    "username": "admin",
    "password": "123456"
  }'
```

#### 12.3.2 发送短信验证码

```bash
curl -X POST "http://localhost:8083/api/auth/send-sms-code?mobile=13800138000"
```

#### 12.3.3 获取用户信息

```bash
# 先登录获取 Token
TOKEN=$(curl -s -X POST http://localhost:8083/api/auth/login \
  -H "Content-Type: application/json" \
  -d '{
    "username": "admin",
    "password": "123456"
  }' | jq -r '.data.token')

# 使用 Token 获取用户信息
curl -X GET http://localhost:8083/api/user/user-info \
  -H "Authorization: Bearer $TOKEN"
```

#### 12.3.4 查看用户分页列表

```bash
curl -X GET "http://localhost:8083/api/user/page?page=1&size=10" \
  -H "Authorization: Bearer $TOKEN"
```

### 12.4 常见问题解决

#### 12.4.1 数据库连接失败

1. 检查 MySQL 服务是否启动
2. 检查数据库连接配置
3. 检查防火墙设置

#### 12.4.2 Redis 连接失败

1. 检查 Redis 服务是否启动
2. 检查 Redis 连接配置
3. 检查 Redis 密码设置

#### 12.4.3 JWT Token 无效

1. 检查 JWT_SECRET 配置
2. 检查 Token 是否过期
3. 检查 Token 是否在黑名单中

#### 12.4.4 Docker 部署问题

1. 检查 Docker 版本是否兼容
2. 检查端口是否被占用
3. 检查环境变量配置

---

## 总结

通过本教程，您已经成功搭建了一个完整的 Spring Boot 3.5.5 企业级 API 项目，包含：

### 核心功能
- ✅ 用户认证与授权（JWT + Spring Security）
- ✅ 用户管理（CRUD 操作）
- ✅ 短信验证码登录
- ✅ 微信登录集成
- ✅ Redis 缓存支持
- ✅ MyBatis-Plus 数据访问
- ✅ API 文档（Knife4j）
- ✅ 统一异常处理
- ✅ 参数校验
- ✅ Docker 部署

### 技术栈
- **框架**: Spring Boot 3.5.5
- **安全**: Spring Security + JWT
- **数据库**: MySQL 8.0 + MyBatis-Plus
- **缓存**: Redis
- **文档**: Knife4j (Swagger 3)
- **工具**: Hutool、Lombok、MapStruct
- **部署**: Docker + Docker Compose

### 项目特点
- 🎯 **代码规范**: 统一的编码规范和项目结构
- 🔒 **安全可靠**: 完整的认证授权机制
- 📚 **文档完善**: 详细的 API 文档和注释
- 🐳 **容器化**: 支持 Docker 部署
- 🚀 **高性能**: 优化的配置和缓存策略
- 🔧 **易于扩展**: 模块化设计，便于功能扩展

### 后续优化方向
1. 添加单元测试和集成测试
2. 实现角色权限管理
3. 添加操作日志记录
4. 实现接口限流和熔断
5. 添加分布式锁支持
6. 实现多数据源配置
7. 添加监控和告警
8. 优化性能和响应速度

希望这个教程对您有所帮助！如有问题，请查阅相关文档或寻求技术支持。